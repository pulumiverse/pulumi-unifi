# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = ['ProfileArgs', 'Profile']

@pulumi.input_type
class ProfileArgs:
    def __init__(__self__, *,
                 autoneg: Optional[pulumi.Input[_builtins.bool]] = None,
                 dot1x_ctrl: Optional[pulumi.Input[_builtins.str]] = None,
                 dot1x_idle_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 egress_rate_limit_kbps: Optional[pulumi.Input[_builtins.int]] = None,
                 egress_rate_limit_kbps_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 excluded_network_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 forward: Optional[pulumi.Input[_builtins.str]] = None,
                 full_duplex: Optional[pulumi.Input[_builtins.bool]] = None,
                 isolation: Optional[pulumi.Input[_builtins.bool]] = None,
                 lldpmed_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 lldpmed_notify_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 native_networkconf_id: Optional[pulumi.Input[_builtins.str]] = None,
                 op_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 poe_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 port_security_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 port_security_mac_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 priority_queue1_level: Optional[pulumi.Input[_builtins.int]] = None,
                 priority_queue2_level: Optional[pulumi.Input[_builtins.int]] = None,
                 priority_queue3_level: Optional[pulumi.Input[_builtins.int]] = None,
                 priority_queue4_level: Optional[pulumi.Input[_builtins.int]] = None,
                 site: Optional[pulumi.Input[_builtins.str]] = None,
                 speed: Optional[pulumi.Input[_builtins.int]] = None,
                 stormctrl_bcast_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 stormctrl_bcast_level: Optional[pulumi.Input[_builtins.int]] = None,
                 stormctrl_bcast_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 stormctrl_mcast_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 stormctrl_mcast_level: Optional[pulumi.Input[_builtins.int]] = None,
                 stormctrl_mcast_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 stormctrl_type: Optional[pulumi.Input[_builtins.str]] = None,
                 stormctrl_ucast_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 stormctrl_ucast_level: Optional[pulumi.Input[_builtins.int]] = None,
                 stormctrl_ucast_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 stp_port_mode: Optional[pulumi.Input[_builtins.bool]] = None,
                 tagged_vlan_mgmt: Optional[pulumi.Input[_builtins.str]] = None,
                 voice_networkconf_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The set of arguments for constructing a Profile resource.
        :param pulumi.Input[_builtins.bool] autoneg: Enable automatic negotiation of port speed and duplex settings. When enabled, this overrides manual speed and duplex settings. Recommended for most use cases.
        :param pulumi.Input[_builtins.str] dot1x_ctrl: 802.1X port-based network access control (PNAC) mode. Valid values are:
                 * `force_authorized` - Port allows all traffic, no authentication required (default)
                 * `force_unauthorized` - Port blocks all traffic regardless of authentication
                 * `auto` - Standard 802.1X authentication required before port access is granted
                 * `mac_based` - Authentication based on client MAC address, useful for devices that don't support 802.1X
                 * `multi_host` - Allows multiple devices after first successful authentication, common in VoIP phone setups
               
               Use 'auto' for highest security, 'mac_based' for legacy devices, and 'multi_host' when daisy-chaining devices.
        :param pulumi.Input[_builtins.int] dot1x_idle_timeout: The number of seconds before an inactive authenticated MAC address is removed when using MAC-based 802.1X control. Range: 0-65535 seconds.
        :param pulumi.Input[_builtins.int] egress_rate_limit_kbps: The maximum outbound bandwidth allowed on the port in kilobits per second. Range: 64-9999999 kbps. Only applied when egress_rate_limit_kbps_enabled is true.
        :param pulumi.Input[_builtins.bool] egress_rate_limit_kbps_enabled: Enable outbound bandwidth rate limiting on the port. When enabled, traffic will be limited to the rate specified in egress_rate_limit_kbps.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] excluded_network_ids: List of network IDs to exclude when forward is set to 'customize'. This allows you to prevent specific networks from being accessible on ports using this profile.
        :param pulumi.Input[_builtins.str] forward: VLAN forwarding mode for the port. Valid values are:
                 * `all` - Forward all VLANs (trunk port)
                 * `native` - Only forward untagged traffic (access port)
                 * `customize` - Forward selected VLANs (use with `excluded_network_ids`)
                 * `disabled` - Disable VLAN forwarding
               
               Examples:
                 * Use 'all' for uplink ports or connections to VLAN-aware devices
                 * Use 'native' for end-user devices or simple network connections
                 * Use 'customize' to create a selective trunk port (e.g., for a server needing access to specific VLANs)
        :param pulumi.Input[_builtins.bool] full_duplex: Enable full-duplex mode when auto-negotiation is disabled. Full duplex allows simultaneous two-way communication.
        :param pulumi.Input[_builtins.bool] isolation: Enable port isolation. When enabled, devices connected to ports with this profile cannot communicate with each other, providing enhanced security.
        :param pulumi.Input[_builtins.bool] lldpmed_enabled: Enable Link Layer Discovery Protocol-Media Endpoint Discovery (LLDP-MED). This allows for automatic discovery and configuration of devices like VoIP phones.
        :param pulumi.Input[_builtins.bool] lldpmed_notify_enabled: Enable LLDP-MED topology change notifications. When enabled:
               * Network devices will be notified of topology changes
               * Useful for VoIP phones and other LLDP-MED capable devices
               * Helps maintain accurate network topology information
               * Facilitates faster device configuration and provisioning
        :param pulumi.Input[_builtins.str] name: A descriptive name for the port profile. Examples:
               * 'AP-Trunk-Port' - For access point uplinks
               * 'VoIP-Phone-Port' - For VoIP phone connections
               * 'User-Access-Port' - For standard user connections
               * 'IoT-Device-Port' - For IoT device connections
        :param pulumi.Input[_builtins.str] native_networkconf_id: The ID of the network to use as the native (untagged) network on ports using this profile. This is typically used for:
               * Access ports where devices need untagged access
               * Trunk ports to specify the native VLAN
               * Management networks for network devices
        :param pulumi.Input[_builtins.str] op_mode: The operation mode for the port profile. Can only be `switch`
        :param pulumi.Input[_builtins.str] poe_mode: The POE mode for the port profile. Can be one of `auto`, `passv24`, `passthrough` or `off`.
        :param pulumi.Input[_builtins.bool] port_security_enabled: Enable MAC address-based port security. When enabled:
               * Only devices with specified MAC addresses can connect
               * Unauthorized devices will be blocked
               * Provides protection against unauthorized network access
               * Must be used with port_security_mac_address list
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] port_security_mac_addresses: List of allowed MAC addresses when port security is enabled. Each address should be:
               * In standard format (e.g., 'aa:bb:cc:dd:ee:ff')
               * Unique per device
               * Verified to belong to authorized devices
               Only effective when port_security_enabled is true
        :param pulumi.Input[_builtins.int] priority_queue1_level: Priority queue 1 level (0-100) for Quality of Service (QoS). Used for:
               * Low-priority background traffic
               * Bulk data transfers
               * Non-time-sensitive applications
               Higher values give more bandwidth to this queue
        :param pulumi.Input[_builtins.int] priority_queue2_level: Priority queue 2 level (0-100) for Quality of Service (QoS). Used for:
               * Standard user traffic
               * Web browsing and email
               * General business applications
               Higher values give more bandwidth to this queue
        :param pulumi.Input[_builtins.int] priority_queue3_level: Priority queue 3 level (0-100) for Quality of Service (QoS). Used for:
               * High-priority traffic
               * Voice and video conferencing
               * Time-sensitive applications
               Higher values give more bandwidth to this queue
        :param pulumi.Input[_builtins.int] priority_queue4_level: Priority queue 4 level (0-100) for Quality of Service (QoS). Used for:
               * Highest priority traffic
               * Critical real-time applications
               * Emergency communications
               Higher values give more bandwidth to this queue
        :param pulumi.Input[_builtins.str] site: The name of the UniFi site where the port profile should be created. If not specified, the default site will be used.
        :param pulumi.Input[_builtins.int] speed: Port speed in Mbps when auto-negotiation is disabled. Common values:
               * 10 - 10 Mbps (legacy devices)
               * 100 - 100 Mbps (Fast Ethernet)
               * 1000 - 1 Gbps (Gigabit Ethernet)
               * 2500 - 2.5 Gbps (Multi-Gigabit)
               * 5000 - 5 Gbps (Multi-Gigabit)
               * 10000 - 10 Gbps (10 Gigabit)
               Only used when autoneg is false
        :param pulumi.Input[_builtins.bool] stormctrl_bcast_enabled: Enable broadcast storm control. When enabled:
               * Limits broadcast traffic to prevent network flooding
               * Protects against broadcast storms
               * Helps maintain network stability
               Use with stormctrl_bcast_rate to set threshold
        :param pulumi.Input[_builtins.int] stormctrl_bcast_level: The broadcast Storm Control level for the port profile. Can be between 0 and 100.
        :param pulumi.Input[_builtins.int] stormctrl_bcast_rate: Maximum broadcast traffic rate in packets per second (0 - 14880000). Used to:
               * Control broadcast traffic levels
               * Prevent network congestion
               * Balance between necessary broadcasts and network protection
               Only effective when `stormctrl_bcast_enabled` is true
        :param pulumi.Input[_builtins.bool] stormctrl_mcast_enabled: Enable multicast storm control. When enabled:
               * Limits multicast traffic to prevent network flooding
               * Important for networks with multicast applications
               * Helps maintain quality of service
               Use with `stormctrl_mcast_rate` to set threshold
        :param pulumi.Input[_builtins.int] stormctrl_mcast_level: The multicast Storm Control level for the port profile. Can be between 0 and 100.
        :param pulumi.Input[_builtins.int] stormctrl_mcast_rate: Maximum multicast traffic rate in packets per second (0 - 14880000). Used to:
               * Control multicast traffic levels
               * Ensure bandwidth for critical multicast services
               * Prevent multicast traffic from overwhelming the network
               Only effective when stormctrl_mcast_enabled is true
        :param pulumi.Input[_builtins.str] stormctrl_type: The type of Storm Control to use for the port profile. Can be one of `level` or `rate`.
        :param pulumi.Input[_builtins.bool] stormctrl_ucast_enabled: Enable unknown unicast storm control. When enabled:
               * Limits unknown unicast traffic to prevent flooding
               * Protects against MAC spoofing attacks
               * Helps maintain network performance
               Use with stormctrl_ucast_rate to set threshold
        :param pulumi.Input[_builtins.int] stormctrl_ucast_level: The unknown unicast Storm Control level for the port profile. Can be between 0 and 100.
        :param pulumi.Input[_builtins.int] stormctrl_ucast_rate: Maximum unknown unicast traffic rate in packets per second (0 - 14880000). Used to:
               * Control unknown unicast traffic levels
               * Prevent network saturation from unknown destinations
               * Balance security with network usability
               Only effective when stormctrl_ucast_enabled is true
        :param pulumi.Input[_builtins.bool] stp_port_mode: Spanning Tree Protocol (STP) configuration for the port. When enabled:
               * Prevents network loops in switch-to-switch connections
               * Provides automatic failover in redundant topologies
               * Helps maintain network stability
               
               Best practices:
               * Enable on switch uplink ports
               * Enable on ports connecting to other switches
               * Can be disabled on end-device ports for faster initialization
        :param pulumi.Input[_builtins.str] tagged_vlan_mgmt: VLAN tagging behavior for the port. Valid values are:
               * `auto` - Automatically handle VLAN tags (recommended)
                   - Intelligently manages tagged and untagged traffic
                   - Best for most deployments
               * `block_all` - Block all VLAN tagged traffic
                   - Use for security-sensitive ports
                   - Prevents VLAN hopping attacks
               * `custom` - Custom VLAN configuration
                   - Manual control over VLAN behavior
                   - For specific VLAN requirements
        :param pulumi.Input[_builtins.str] voice_networkconf_id: The ID of the network to use for Voice over IP (VoIP) traffic. Used for:
               * Automatic VoIP VLAN configuration
               * Voice traffic prioritization
               * QoS settings for voice packets
               
               Common scenarios:
               * IP phone deployments with separate voice VLAN
               * Unified communications systems
               * Converged voice/data networks
               
               Works in conjunction with LLDP-MED for automatic phone provisioning.
        """
        if autoneg is not None:
            pulumi.set(__self__, "autoneg", autoneg)
        if dot1x_ctrl is not None:
            pulumi.set(__self__, "dot1x_ctrl", dot1x_ctrl)
        if dot1x_idle_timeout is not None:
            pulumi.set(__self__, "dot1x_idle_timeout", dot1x_idle_timeout)
        if egress_rate_limit_kbps is not None:
            pulumi.set(__self__, "egress_rate_limit_kbps", egress_rate_limit_kbps)
        if egress_rate_limit_kbps_enabled is not None:
            pulumi.set(__self__, "egress_rate_limit_kbps_enabled", egress_rate_limit_kbps_enabled)
        if excluded_network_ids is not None:
            pulumi.set(__self__, "excluded_network_ids", excluded_network_ids)
        if forward is not None:
            pulumi.set(__self__, "forward", forward)
        if full_duplex is not None:
            pulumi.set(__self__, "full_duplex", full_duplex)
        if isolation is not None:
            pulumi.set(__self__, "isolation", isolation)
        if lldpmed_enabled is not None:
            pulumi.set(__self__, "lldpmed_enabled", lldpmed_enabled)
        if lldpmed_notify_enabled is not None:
            pulumi.set(__self__, "lldpmed_notify_enabled", lldpmed_notify_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if native_networkconf_id is not None:
            pulumi.set(__self__, "native_networkconf_id", native_networkconf_id)
        if op_mode is not None:
            pulumi.set(__self__, "op_mode", op_mode)
        if poe_mode is not None:
            pulumi.set(__self__, "poe_mode", poe_mode)
        if port_security_enabled is not None:
            pulumi.set(__self__, "port_security_enabled", port_security_enabled)
        if port_security_mac_addresses is not None:
            pulumi.set(__self__, "port_security_mac_addresses", port_security_mac_addresses)
        if priority_queue1_level is not None:
            pulumi.set(__self__, "priority_queue1_level", priority_queue1_level)
        if priority_queue2_level is not None:
            pulumi.set(__self__, "priority_queue2_level", priority_queue2_level)
        if priority_queue3_level is not None:
            pulumi.set(__self__, "priority_queue3_level", priority_queue3_level)
        if priority_queue4_level is not None:
            pulumi.set(__self__, "priority_queue4_level", priority_queue4_level)
        if site is not None:
            pulumi.set(__self__, "site", site)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)
        if stormctrl_bcast_enabled is not None:
            pulumi.set(__self__, "stormctrl_bcast_enabled", stormctrl_bcast_enabled)
        if stormctrl_bcast_level is not None:
            pulumi.set(__self__, "stormctrl_bcast_level", stormctrl_bcast_level)
        if stormctrl_bcast_rate is not None:
            pulumi.set(__self__, "stormctrl_bcast_rate", stormctrl_bcast_rate)
        if stormctrl_mcast_enabled is not None:
            pulumi.set(__self__, "stormctrl_mcast_enabled", stormctrl_mcast_enabled)
        if stormctrl_mcast_level is not None:
            pulumi.set(__self__, "stormctrl_mcast_level", stormctrl_mcast_level)
        if stormctrl_mcast_rate is not None:
            pulumi.set(__self__, "stormctrl_mcast_rate", stormctrl_mcast_rate)
        if stormctrl_type is not None:
            pulumi.set(__self__, "stormctrl_type", stormctrl_type)
        if stormctrl_ucast_enabled is not None:
            pulumi.set(__self__, "stormctrl_ucast_enabled", stormctrl_ucast_enabled)
        if stormctrl_ucast_level is not None:
            pulumi.set(__self__, "stormctrl_ucast_level", stormctrl_ucast_level)
        if stormctrl_ucast_rate is not None:
            pulumi.set(__self__, "stormctrl_ucast_rate", stormctrl_ucast_rate)
        if stp_port_mode is not None:
            pulumi.set(__self__, "stp_port_mode", stp_port_mode)
        if tagged_vlan_mgmt is not None:
            pulumi.set(__self__, "tagged_vlan_mgmt", tagged_vlan_mgmt)
        if voice_networkconf_id is not None:
            pulumi.set(__self__, "voice_networkconf_id", voice_networkconf_id)

    @_builtins.property
    @pulumi.getter
    def autoneg(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable automatic negotiation of port speed and duplex settings. When enabled, this overrides manual speed and duplex settings. Recommended for most use cases.
        """
        return pulumi.get(self, "autoneg")

    @autoneg.setter
    def autoneg(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "autoneg", value)

    @_builtins.property
    @pulumi.getter(name="dot1xCtrl")
    def dot1x_ctrl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        802.1X port-based network access control (PNAC) mode. Valid values are:
          * `force_authorized` - Port allows all traffic, no authentication required (default)
          * `force_unauthorized` - Port blocks all traffic regardless of authentication
          * `auto` - Standard 802.1X authentication required before port access is granted
          * `mac_based` - Authentication based on client MAC address, useful for devices that don't support 802.1X
          * `multi_host` - Allows multiple devices after first successful authentication, common in VoIP phone setups

        Use 'auto' for highest security, 'mac_based' for legacy devices, and 'multi_host' when daisy-chaining devices.
        """
        return pulumi.get(self, "dot1x_ctrl")

    @dot1x_ctrl.setter
    def dot1x_ctrl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dot1x_ctrl", value)

    @_builtins.property
    @pulumi.getter(name="dot1xIdleTimeout")
    def dot1x_idle_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds before an inactive authenticated MAC address is removed when using MAC-based 802.1X control. Range: 0-65535 seconds.
        """
        return pulumi.get(self, "dot1x_idle_timeout")

    @dot1x_idle_timeout.setter
    def dot1x_idle_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "dot1x_idle_timeout", value)

    @_builtins.property
    @pulumi.getter(name="egressRateLimitKbps")
    def egress_rate_limit_kbps(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum outbound bandwidth allowed on the port in kilobits per second. Range: 64-9999999 kbps. Only applied when egress_rate_limit_kbps_enabled is true.
        """
        return pulumi.get(self, "egress_rate_limit_kbps")

    @egress_rate_limit_kbps.setter
    def egress_rate_limit_kbps(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "egress_rate_limit_kbps", value)

    @_builtins.property
    @pulumi.getter(name="egressRateLimitKbpsEnabled")
    def egress_rate_limit_kbps_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable outbound bandwidth rate limiting on the port. When enabled, traffic will be limited to the rate specified in egress_rate_limit_kbps.
        """
        return pulumi.get(self, "egress_rate_limit_kbps_enabled")

    @egress_rate_limit_kbps_enabled.setter
    def egress_rate_limit_kbps_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "egress_rate_limit_kbps_enabled", value)

    @_builtins.property
    @pulumi.getter(name="excludedNetworkIds")
    def excluded_network_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of network IDs to exclude when forward is set to 'customize'. This allows you to prevent specific networks from being accessible on ports using this profile.
        """
        return pulumi.get(self, "excluded_network_ids")

    @excluded_network_ids.setter
    def excluded_network_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_network_ids", value)

    @_builtins.property
    @pulumi.getter
    def forward(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        VLAN forwarding mode for the port. Valid values are:
          * `all` - Forward all VLANs (trunk port)
          * `native` - Only forward untagged traffic (access port)
          * `customize` - Forward selected VLANs (use with `excluded_network_ids`)
          * `disabled` - Disable VLAN forwarding

        Examples:
          * Use 'all' for uplink ports or connections to VLAN-aware devices
          * Use 'native' for end-user devices or simple network connections
          * Use 'customize' to create a selective trunk port (e.g., for a server needing access to specific VLANs)
        """
        return pulumi.get(self, "forward")

    @forward.setter
    def forward(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "forward", value)

    @_builtins.property
    @pulumi.getter(name="fullDuplex")
    def full_duplex(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable full-duplex mode when auto-negotiation is disabled. Full duplex allows simultaneous two-way communication.
        """
        return pulumi.get(self, "full_duplex")

    @full_duplex.setter
    def full_duplex(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "full_duplex", value)

    @_builtins.property
    @pulumi.getter
    def isolation(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable port isolation. When enabled, devices connected to ports with this profile cannot communicate with each other, providing enhanced security.
        """
        return pulumi.get(self, "isolation")

    @isolation.setter
    def isolation(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "isolation", value)

    @_builtins.property
    @pulumi.getter(name="lldpmedEnabled")
    def lldpmed_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable Link Layer Discovery Protocol-Media Endpoint Discovery (LLDP-MED). This allows for automatic discovery and configuration of devices like VoIP phones.
        """
        return pulumi.get(self, "lldpmed_enabled")

    @lldpmed_enabled.setter
    def lldpmed_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "lldpmed_enabled", value)

    @_builtins.property
    @pulumi.getter(name="lldpmedNotifyEnabled")
    def lldpmed_notify_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable LLDP-MED topology change notifications. When enabled:
        * Network devices will be notified of topology changes
        * Useful for VoIP phones and other LLDP-MED capable devices
        * Helps maintain accurate network topology information
        * Facilitates faster device configuration and provisioning
        """
        return pulumi.get(self, "lldpmed_notify_enabled")

    @lldpmed_notify_enabled.setter
    def lldpmed_notify_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "lldpmed_notify_enabled", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A descriptive name for the port profile. Examples:
        * 'AP-Trunk-Port' - For access point uplinks
        * 'VoIP-Phone-Port' - For VoIP phone connections
        * 'User-Access-Port' - For standard user connections
        * 'IoT-Device-Port' - For IoT device connections
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="nativeNetworkconfId")
    def native_networkconf_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the network to use as the native (untagged) network on ports using this profile. This is typically used for:
        * Access ports where devices need untagged access
        * Trunk ports to specify the native VLAN
        * Management networks for network devices
        """
        return pulumi.get(self, "native_networkconf_id")

    @native_networkconf_id.setter
    def native_networkconf_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "native_networkconf_id", value)

    @_builtins.property
    @pulumi.getter(name="opMode")
    def op_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The operation mode for the port profile. Can only be `switch`
        """
        return pulumi.get(self, "op_mode")

    @op_mode.setter
    def op_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "op_mode", value)

    @_builtins.property
    @pulumi.getter(name="poeMode")
    def poe_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The POE mode for the port profile. Can be one of `auto`, `passv24`, `passthrough` or `off`.
        """
        return pulumi.get(self, "poe_mode")

    @poe_mode.setter
    def poe_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "poe_mode", value)

    @_builtins.property
    @pulumi.getter(name="portSecurityEnabled")
    def port_security_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable MAC address-based port security. When enabled:
        * Only devices with specified MAC addresses can connect
        * Unauthorized devices will be blocked
        * Provides protection against unauthorized network access
        * Must be used with port_security_mac_address list
        """
        return pulumi.get(self, "port_security_enabled")

    @port_security_enabled.setter
    def port_security_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "port_security_enabled", value)

    @_builtins.property
    @pulumi.getter(name="portSecurityMacAddresses")
    def port_security_mac_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of allowed MAC addresses when port security is enabled. Each address should be:
        * In standard format (e.g., 'aa:bb:cc:dd:ee:ff')
        * Unique per device
        * Verified to belong to authorized devices
        Only effective when port_security_enabled is true
        """
        return pulumi.get(self, "port_security_mac_addresses")

    @port_security_mac_addresses.setter
    def port_security_mac_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "port_security_mac_addresses", value)

    @_builtins.property
    @pulumi.getter(name="priorityQueue1Level")
    def priority_queue1_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Priority queue 1 level (0-100) for Quality of Service (QoS). Used for:
        * Low-priority background traffic
        * Bulk data transfers
        * Non-time-sensitive applications
        Higher values give more bandwidth to this queue
        """
        return pulumi.get(self, "priority_queue1_level")

    @priority_queue1_level.setter
    def priority_queue1_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority_queue1_level", value)

    @_builtins.property
    @pulumi.getter(name="priorityQueue2Level")
    def priority_queue2_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Priority queue 2 level (0-100) for Quality of Service (QoS). Used for:
        * Standard user traffic
        * Web browsing and email
        * General business applications
        Higher values give more bandwidth to this queue
        """
        return pulumi.get(self, "priority_queue2_level")

    @priority_queue2_level.setter
    def priority_queue2_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority_queue2_level", value)

    @_builtins.property
    @pulumi.getter(name="priorityQueue3Level")
    def priority_queue3_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Priority queue 3 level (0-100) for Quality of Service (QoS). Used for:
        * High-priority traffic
        * Voice and video conferencing
        * Time-sensitive applications
        Higher values give more bandwidth to this queue
        """
        return pulumi.get(self, "priority_queue3_level")

    @priority_queue3_level.setter
    def priority_queue3_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority_queue3_level", value)

    @_builtins.property
    @pulumi.getter(name="priorityQueue4Level")
    def priority_queue4_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Priority queue 4 level (0-100) for Quality of Service (QoS). Used for:
        * Highest priority traffic
        * Critical real-time applications
        * Emergency communications
        Higher values give more bandwidth to this queue
        """
        return pulumi.get(self, "priority_queue4_level")

    @priority_queue4_level.setter
    def priority_queue4_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority_queue4_level", value)

    @_builtins.property
    @pulumi.getter
    def site(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the UniFi site where the port profile should be created. If not specified, the default site will be used.
        """
        return pulumi.get(self, "site")

    @site.setter
    def site(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "site", value)

    @_builtins.property
    @pulumi.getter
    def speed(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port speed in Mbps when auto-negotiation is disabled. Common values:
        * 10 - 10 Mbps (legacy devices)
        * 100 - 100 Mbps (Fast Ethernet)
        * 1000 - 1 Gbps (Gigabit Ethernet)
        * 2500 - 2.5 Gbps (Multi-Gigabit)
        * 5000 - 5 Gbps (Multi-Gigabit)
        * 10000 - 10 Gbps (10 Gigabit)
        Only used when autoneg is false
        """
        return pulumi.get(self, "speed")

    @speed.setter
    def speed(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "speed", value)

    @_builtins.property
    @pulumi.getter(name="stormctrlBcastEnabled")
    def stormctrl_bcast_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable broadcast storm control. When enabled:
        * Limits broadcast traffic to prevent network flooding
        * Protects against broadcast storms
        * Helps maintain network stability
        Use with stormctrl_bcast_rate to set threshold
        """
        return pulumi.get(self, "stormctrl_bcast_enabled")

    @stormctrl_bcast_enabled.setter
    def stormctrl_bcast_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "stormctrl_bcast_enabled", value)

    @_builtins.property
    @pulumi.getter(name="stormctrlBcastLevel")
    def stormctrl_bcast_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The broadcast Storm Control level for the port profile. Can be between 0 and 100.
        """
        return pulumi.get(self, "stormctrl_bcast_level")

    @stormctrl_bcast_level.setter
    def stormctrl_bcast_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "stormctrl_bcast_level", value)

    @_builtins.property
    @pulumi.getter(name="stormctrlBcastRate")
    def stormctrl_bcast_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum broadcast traffic rate in packets per second (0 - 14880000). Used to:
        * Control broadcast traffic levels
        * Prevent network congestion
        * Balance between necessary broadcasts and network protection
        Only effective when `stormctrl_bcast_enabled` is true
        """
        return pulumi.get(self, "stormctrl_bcast_rate")

    @stormctrl_bcast_rate.setter
    def stormctrl_bcast_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "stormctrl_bcast_rate", value)

    @_builtins.property
    @pulumi.getter(name="stormctrlMcastEnabled")
    def stormctrl_mcast_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable multicast storm control. When enabled:
        * Limits multicast traffic to prevent network flooding
        * Important for networks with multicast applications
        * Helps maintain quality of service
        Use with `stormctrl_mcast_rate` to set threshold
        """
        return pulumi.get(self, "stormctrl_mcast_enabled")

    @stormctrl_mcast_enabled.setter
    def stormctrl_mcast_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "stormctrl_mcast_enabled", value)

    @_builtins.property
    @pulumi.getter(name="stormctrlMcastLevel")
    def stormctrl_mcast_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The multicast Storm Control level for the port profile. Can be between 0 and 100.
        """
        return pulumi.get(self, "stormctrl_mcast_level")

    @stormctrl_mcast_level.setter
    def stormctrl_mcast_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "stormctrl_mcast_level", value)

    @_builtins.property
    @pulumi.getter(name="stormctrlMcastRate")
    def stormctrl_mcast_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum multicast traffic rate in packets per second (0 - 14880000). Used to:
        * Control multicast traffic levels
        * Ensure bandwidth for critical multicast services
        * Prevent multicast traffic from overwhelming the network
        Only effective when stormctrl_mcast_enabled is true
        """
        return pulumi.get(self, "stormctrl_mcast_rate")

    @stormctrl_mcast_rate.setter
    def stormctrl_mcast_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "stormctrl_mcast_rate", value)

    @_builtins.property
    @pulumi.getter(name="stormctrlType")
    def stormctrl_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of Storm Control to use for the port profile. Can be one of `level` or `rate`.
        """
        return pulumi.get(self, "stormctrl_type")

    @stormctrl_type.setter
    def stormctrl_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "stormctrl_type", value)

    @_builtins.property
    @pulumi.getter(name="stormctrlUcastEnabled")
    def stormctrl_ucast_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable unknown unicast storm control. When enabled:
        * Limits unknown unicast traffic to prevent flooding
        * Protects against MAC spoofing attacks
        * Helps maintain network performance
        Use with stormctrl_ucast_rate to set threshold
        """
        return pulumi.get(self, "stormctrl_ucast_enabled")

    @stormctrl_ucast_enabled.setter
    def stormctrl_ucast_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "stormctrl_ucast_enabled", value)

    @_builtins.property
    @pulumi.getter(name="stormctrlUcastLevel")
    def stormctrl_ucast_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The unknown unicast Storm Control level for the port profile. Can be between 0 and 100.
        """
        return pulumi.get(self, "stormctrl_ucast_level")

    @stormctrl_ucast_level.setter
    def stormctrl_ucast_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "stormctrl_ucast_level", value)

    @_builtins.property
    @pulumi.getter(name="stormctrlUcastRate")
    def stormctrl_ucast_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum unknown unicast traffic rate in packets per second (0 - 14880000). Used to:
        * Control unknown unicast traffic levels
        * Prevent network saturation from unknown destinations
        * Balance security with network usability
        Only effective when stormctrl_ucast_enabled is true
        """
        return pulumi.get(self, "stormctrl_ucast_rate")

    @stormctrl_ucast_rate.setter
    def stormctrl_ucast_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "stormctrl_ucast_rate", value)

    @_builtins.property
    @pulumi.getter(name="stpPortMode")
    def stp_port_mode(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Spanning Tree Protocol (STP) configuration for the port. When enabled:
        * Prevents network loops in switch-to-switch connections
        * Provides automatic failover in redundant topologies
        * Helps maintain network stability

        Best practices:
        * Enable on switch uplink ports
        * Enable on ports connecting to other switches
        * Can be disabled on end-device ports for faster initialization
        """
        return pulumi.get(self, "stp_port_mode")

    @stp_port_mode.setter
    def stp_port_mode(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "stp_port_mode", value)

    @_builtins.property
    @pulumi.getter(name="taggedVlanMgmt")
    def tagged_vlan_mgmt(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        VLAN tagging behavior for the port. Valid values are:
        * `auto` - Automatically handle VLAN tags (recommended)
            - Intelligently manages tagged and untagged traffic
            - Best for most deployments
        * `block_all` - Block all VLAN tagged traffic
            - Use for security-sensitive ports
            - Prevents VLAN hopping attacks
        * `custom` - Custom VLAN configuration
            - Manual control over VLAN behavior
            - For specific VLAN requirements
        """
        return pulumi.get(self, "tagged_vlan_mgmt")

    @tagged_vlan_mgmt.setter
    def tagged_vlan_mgmt(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tagged_vlan_mgmt", value)

    @_builtins.property
    @pulumi.getter(name="voiceNetworkconfId")
    def voice_networkconf_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the network to use for Voice over IP (VoIP) traffic. Used for:
        * Automatic VoIP VLAN configuration
        * Voice traffic prioritization
        * QoS settings for voice packets

        Common scenarios:
        * IP phone deployments with separate voice VLAN
        * Unified communications systems
        * Converged voice/data networks

        Works in conjunction with LLDP-MED for automatic phone provisioning.
        """
        return pulumi.get(self, "voice_networkconf_id")

    @voice_networkconf_id.setter
    def voice_networkconf_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "voice_networkconf_id", value)


@pulumi.input_type
class _ProfileState:
    def __init__(__self__, *,
                 autoneg: Optional[pulumi.Input[_builtins.bool]] = None,
                 dot1x_ctrl: Optional[pulumi.Input[_builtins.str]] = None,
                 dot1x_idle_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 egress_rate_limit_kbps: Optional[pulumi.Input[_builtins.int]] = None,
                 egress_rate_limit_kbps_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 excluded_network_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 forward: Optional[pulumi.Input[_builtins.str]] = None,
                 full_duplex: Optional[pulumi.Input[_builtins.bool]] = None,
                 isolation: Optional[pulumi.Input[_builtins.bool]] = None,
                 lldpmed_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 lldpmed_notify_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 native_networkconf_id: Optional[pulumi.Input[_builtins.str]] = None,
                 op_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 poe_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 port_security_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 port_security_mac_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 priority_queue1_level: Optional[pulumi.Input[_builtins.int]] = None,
                 priority_queue2_level: Optional[pulumi.Input[_builtins.int]] = None,
                 priority_queue3_level: Optional[pulumi.Input[_builtins.int]] = None,
                 priority_queue4_level: Optional[pulumi.Input[_builtins.int]] = None,
                 site: Optional[pulumi.Input[_builtins.str]] = None,
                 speed: Optional[pulumi.Input[_builtins.int]] = None,
                 stormctrl_bcast_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 stormctrl_bcast_level: Optional[pulumi.Input[_builtins.int]] = None,
                 stormctrl_bcast_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 stormctrl_mcast_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 stormctrl_mcast_level: Optional[pulumi.Input[_builtins.int]] = None,
                 stormctrl_mcast_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 stormctrl_type: Optional[pulumi.Input[_builtins.str]] = None,
                 stormctrl_ucast_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 stormctrl_ucast_level: Optional[pulumi.Input[_builtins.int]] = None,
                 stormctrl_ucast_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 stp_port_mode: Optional[pulumi.Input[_builtins.bool]] = None,
                 tagged_vlan_mgmt: Optional[pulumi.Input[_builtins.str]] = None,
                 voice_networkconf_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Input properties used for looking up and filtering Profile resources.
        :param pulumi.Input[_builtins.bool] autoneg: Enable automatic negotiation of port speed and duplex settings. When enabled, this overrides manual speed and duplex settings. Recommended for most use cases.
        :param pulumi.Input[_builtins.str] dot1x_ctrl: 802.1X port-based network access control (PNAC) mode. Valid values are:
                 * `force_authorized` - Port allows all traffic, no authentication required (default)
                 * `force_unauthorized` - Port blocks all traffic regardless of authentication
                 * `auto` - Standard 802.1X authentication required before port access is granted
                 * `mac_based` - Authentication based on client MAC address, useful for devices that don't support 802.1X
                 * `multi_host` - Allows multiple devices after first successful authentication, common in VoIP phone setups
               
               Use 'auto' for highest security, 'mac_based' for legacy devices, and 'multi_host' when daisy-chaining devices.
        :param pulumi.Input[_builtins.int] dot1x_idle_timeout: The number of seconds before an inactive authenticated MAC address is removed when using MAC-based 802.1X control. Range: 0-65535 seconds.
        :param pulumi.Input[_builtins.int] egress_rate_limit_kbps: The maximum outbound bandwidth allowed on the port in kilobits per second. Range: 64-9999999 kbps. Only applied when egress_rate_limit_kbps_enabled is true.
        :param pulumi.Input[_builtins.bool] egress_rate_limit_kbps_enabled: Enable outbound bandwidth rate limiting on the port. When enabled, traffic will be limited to the rate specified in egress_rate_limit_kbps.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] excluded_network_ids: List of network IDs to exclude when forward is set to 'customize'. This allows you to prevent specific networks from being accessible on ports using this profile.
        :param pulumi.Input[_builtins.str] forward: VLAN forwarding mode for the port. Valid values are:
                 * `all` - Forward all VLANs (trunk port)
                 * `native` - Only forward untagged traffic (access port)
                 * `customize` - Forward selected VLANs (use with `excluded_network_ids`)
                 * `disabled` - Disable VLAN forwarding
               
               Examples:
                 * Use 'all' for uplink ports or connections to VLAN-aware devices
                 * Use 'native' for end-user devices or simple network connections
                 * Use 'customize' to create a selective trunk port (e.g., for a server needing access to specific VLANs)
        :param pulumi.Input[_builtins.bool] full_duplex: Enable full-duplex mode when auto-negotiation is disabled. Full duplex allows simultaneous two-way communication.
        :param pulumi.Input[_builtins.bool] isolation: Enable port isolation. When enabled, devices connected to ports with this profile cannot communicate with each other, providing enhanced security.
        :param pulumi.Input[_builtins.bool] lldpmed_enabled: Enable Link Layer Discovery Protocol-Media Endpoint Discovery (LLDP-MED). This allows for automatic discovery and configuration of devices like VoIP phones.
        :param pulumi.Input[_builtins.bool] lldpmed_notify_enabled: Enable LLDP-MED topology change notifications. When enabled:
               * Network devices will be notified of topology changes
               * Useful for VoIP phones and other LLDP-MED capable devices
               * Helps maintain accurate network topology information
               * Facilitates faster device configuration and provisioning
        :param pulumi.Input[_builtins.str] name: A descriptive name for the port profile. Examples:
               * 'AP-Trunk-Port' - For access point uplinks
               * 'VoIP-Phone-Port' - For VoIP phone connections
               * 'User-Access-Port' - For standard user connections
               * 'IoT-Device-Port' - For IoT device connections
        :param pulumi.Input[_builtins.str] native_networkconf_id: The ID of the network to use as the native (untagged) network on ports using this profile. This is typically used for:
               * Access ports where devices need untagged access
               * Trunk ports to specify the native VLAN
               * Management networks for network devices
        :param pulumi.Input[_builtins.str] op_mode: The operation mode for the port profile. Can only be `switch`
        :param pulumi.Input[_builtins.str] poe_mode: The POE mode for the port profile. Can be one of `auto`, `passv24`, `passthrough` or `off`.
        :param pulumi.Input[_builtins.bool] port_security_enabled: Enable MAC address-based port security. When enabled:
               * Only devices with specified MAC addresses can connect
               * Unauthorized devices will be blocked
               * Provides protection against unauthorized network access
               * Must be used with port_security_mac_address list
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] port_security_mac_addresses: List of allowed MAC addresses when port security is enabled. Each address should be:
               * In standard format (e.g., 'aa:bb:cc:dd:ee:ff')
               * Unique per device
               * Verified to belong to authorized devices
               Only effective when port_security_enabled is true
        :param pulumi.Input[_builtins.int] priority_queue1_level: Priority queue 1 level (0-100) for Quality of Service (QoS). Used for:
               * Low-priority background traffic
               * Bulk data transfers
               * Non-time-sensitive applications
               Higher values give more bandwidth to this queue
        :param pulumi.Input[_builtins.int] priority_queue2_level: Priority queue 2 level (0-100) for Quality of Service (QoS). Used for:
               * Standard user traffic
               * Web browsing and email
               * General business applications
               Higher values give more bandwidth to this queue
        :param pulumi.Input[_builtins.int] priority_queue3_level: Priority queue 3 level (0-100) for Quality of Service (QoS). Used for:
               * High-priority traffic
               * Voice and video conferencing
               * Time-sensitive applications
               Higher values give more bandwidth to this queue
        :param pulumi.Input[_builtins.int] priority_queue4_level: Priority queue 4 level (0-100) for Quality of Service (QoS). Used for:
               * Highest priority traffic
               * Critical real-time applications
               * Emergency communications
               Higher values give more bandwidth to this queue
        :param pulumi.Input[_builtins.str] site: The name of the UniFi site where the port profile should be created. If not specified, the default site will be used.
        :param pulumi.Input[_builtins.int] speed: Port speed in Mbps when auto-negotiation is disabled. Common values:
               * 10 - 10 Mbps (legacy devices)
               * 100 - 100 Mbps (Fast Ethernet)
               * 1000 - 1 Gbps (Gigabit Ethernet)
               * 2500 - 2.5 Gbps (Multi-Gigabit)
               * 5000 - 5 Gbps (Multi-Gigabit)
               * 10000 - 10 Gbps (10 Gigabit)
               Only used when autoneg is false
        :param pulumi.Input[_builtins.bool] stormctrl_bcast_enabled: Enable broadcast storm control. When enabled:
               * Limits broadcast traffic to prevent network flooding
               * Protects against broadcast storms
               * Helps maintain network stability
               Use with stormctrl_bcast_rate to set threshold
        :param pulumi.Input[_builtins.int] stormctrl_bcast_level: The broadcast Storm Control level for the port profile. Can be between 0 and 100.
        :param pulumi.Input[_builtins.int] stormctrl_bcast_rate: Maximum broadcast traffic rate in packets per second (0 - 14880000). Used to:
               * Control broadcast traffic levels
               * Prevent network congestion
               * Balance between necessary broadcasts and network protection
               Only effective when `stormctrl_bcast_enabled` is true
        :param pulumi.Input[_builtins.bool] stormctrl_mcast_enabled: Enable multicast storm control. When enabled:
               * Limits multicast traffic to prevent network flooding
               * Important for networks with multicast applications
               * Helps maintain quality of service
               Use with `stormctrl_mcast_rate` to set threshold
        :param pulumi.Input[_builtins.int] stormctrl_mcast_level: The multicast Storm Control level for the port profile. Can be between 0 and 100.
        :param pulumi.Input[_builtins.int] stormctrl_mcast_rate: Maximum multicast traffic rate in packets per second (0 - 14880000). Used to:
               * Control multicast traffic levels
               * Ensure bandwidth for critical multicast services
               * Prevent multicast traffic from overwhelming the network
               Only effective when stormctrl_mcast_enabled is true
        :param pulumi.Input[_builtins.str] stormctrl_type: The type of Storm Control to use for the port profile. Can be one of `level` or `rate`.
        :param pulumi.Input[_builtins.bool] stormctrl_ucast_enabled: Enable unknown unicast storm control. When enabled:
               * Limits unknown unicast traffic to prevent flooding
               * Protects against MAC spoofing attacks
               * Helps maintain network performance
               Use with stormctrl_ucast_rate to set threshold
        :param pulumi.Input[_builtins.int] stormctrl_ucast_level: The unknown unicast Storm Control level for the port profile. Can be between 0 and 100.
        :param pulumi.Input[_builtins.int] stormctrl_ucast_rate: Maximum unknown unicast traffic rate in packets per second (0 - 14880000). Used to:
               * Control unknown unicast traffic levels
               * Prevent network saturation from unknown destinations
               * Balance security with network usability
               Only effective when stormctrl_ucast_enabled is true
        :param pulumi.Input[_builtins.bool] stp_port_mode: Spanning Tree Protocol (STP) configuration for the port. When enabled:
               * Prevents network loops in switch-to-switch connections
               * Provides automatic failover in redundant topologies
               * Helps maintain network stability
               
               Best practices:
               * Enable on switch uplink ports
               * Enable on ports connecting to other switches
               * Can be disabled on end-device ports for faster initialization
        :param pulumi.Input[_builtins.str] tagged_vlan_mgmt: VLAN tagging behavior for the port. Valid values are:
               * `auto` - Automatically handle VLAN tags (recommended)
                   - Intelligently manages tagged and untagged traffic
                   - Best for most deployments
               * `block_all` - Block all VLAN tagged traffic
                   - Use for security-sensitive ports
                   - Prevents VLAN hopping attacks
               * `custom` - Custom VLAN configuration
                   - Manual control over VLAN behavior
                   - For specific VLAN requirements
        :param pulumi.Input[_builtins.str] voice_networkconf_id: The ID of the network to use for Voice over IP (VoIP) traffic. Used for:
               * Automatic VoIP VLAN configuration
               * Voice traffic prioritization
               * QoS settings for voice packets
               
               Common scenarios:
               * IP phone deployments with separate voice VLAN
               * Unified communications systems
               * Converged voice/data networks
               
               Works in conjunction with LLDP-MED for automatic phone provisioning.
        """
        if autoneg is not None:
            pulumi.set(__self__, "autoneg", autoneg)
        if dot1x_ctrl is not None:
            pulumi.set(__self__, "dot1x_ctrl", dot1x_ctrl)
        if dot1x_idle_timeout is not None:
            pulumi.set(__self__, "dot1x_idle_timeout", dot1x_idle_timeout)
        if egress_rate_limit_kbps is not None:
            pulumi.set(__self__, "egress_rate_limit_kbps", egress_rate_limit_kbps)
        if egress_rate_limit_kbps_enabled is not None:
            pulumi.set(__self__, "egress_rate_limit_kbps_enabled", egress_rate_limit_kbps_enabled)
        if excluded_network_ids is not None:
            pulumi.set(__self__, "excluded_network_ids", excluded_network_ids)
        if forward is not None:
            pulumi.set(__self__, "forward", forward)
        if full_duplex is not None:
            pulumi.set(__self__, "full_duplex", full_duplex)
        if isolation is not None:
            pulumi.set(__self__, "isolation", isolation)
        if lldpmed_enabled is not None:
            pulumi.set(__self__, "lldpmed_enabled", lldpmed_enabled)
        if lldpmed_notify_enabled is not None:
            pulumi.set(__self__, "lldpmed_notify_enabled", lldpmed_notify_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if native_networkconf_id is not None:
            pulumi.set(__self__, "native_networkconf_id", native_networkconf_id)
        if op_mode is not None:
            pulumi.set(__self__, "op_mode", op_mode)
        if poe_mode is not None:
            pulumi.set(__self__, "poe_mode", poe_mode)
        if port_security_enabled is not None:
            pulumi.set(__self__, "port_security_enabled", port_security_enabled)
        if port_security_mac_addresses is not None:
            pulumi.set(__self__, "port_security_mac_addresses", port_security_mac_addresses)
        if priority_queue1_level is not None:
            pulumi.set(__self__, "priority_queue1_level", priority_queue1_level)
        if priority_queue2_level is not None:
            pulumi.set(__self__, "priority_queue2_level", priority_queue2_level)
        if priority_queue3_level is not None:
            pulumi.set(__self__, "priority_queue3_level", priority_queue3_level)
        if priority_queue4_level is not None:
            pulumi.set(__self__, "priority_queue4_level", priority_queue4_level)
        if site is not None:
            pulumi.set(__self__, "site", site)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)
        if stormctrl_bcast_enabled is not None:
            pulumi.set(__self__, "stormctrl_bcast_enabled", stormctrl_bcast_enabled)
        if stormctrl_bcast_level is not None:
            pulumi.set(__self__, "stormctrl_bcast_level", stormctrl_bcast_level)
        if stormctrl_bcast_rate is not None:
            pulumi.set(__self__, "stormctrl_bcast_rate", stormctrl_bcast_rate)
        if stormctrl_mcast_enabled is not None:
            pulumi.set(__self__, "stormctrl_mcast_enabled", stormctrl_mcast_enabled)
        if stormctrl_mcast_level is not None:
            pulumi.set(__self__, "stormctrl_mcast_level", stormctrl_mcast_level)
        if stormctrl_mcast_rate is not None:
            pulumi.set(__self__, "stormctrl_mcast_rate", stormctrl_mcast_rate)
        if stormctrl_type is not None:
            pulumi.set(__self__, "stormctrl_type", stormctrl_type)
        if stormctrl_ucast_enabled is not None:
            pulumi.set(__self__, "stormctrl_ucast_enabled", stormctrl_ucast_enabled)
        if stormctrl_ucast_level is not None:
            pulumi.set(__self__, "stormctrl_ucast_level", stormctrl_ucast_level)
        if stormctrl_ucast_rate is not None:
            pulumi.set(__self__, "stormctrl_ucast_rate", stormctrl_ucast_rate)
        if stp_port_mode is not None:
            pulumi.set(__self__, "stp_port_mode", stp_port_mode)
        if tagged_vlan_mgmt is not None:
            pulumi.set(__self__, "tagged_vlan_mgmt", tagged_vlan_mgmt)
        if voice_networkconf_id is not None:
            pulumi.set(__self__, "voice_networkconf_id", voice_networkconf_id)

    @_builtins.property
    @pulumi.getter
    def autoneg(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable automatic negotiation of port speed and duplex settings. When enabled, this overrides manual speed and duplex settings. Recommended for most use cases.
        """
        return pulumi.get(self, "autoneg")

    @autoneg.setter
    def autoneg(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "autoneg", value)

    @_builtins.property
    @pulumi.getter(name="dot1xCtrl")
    def dot1x_ctrl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        802.1X port-based network access control (PNAC) mode. Valid values are:
          * `force_authorized` - Port allows all traffic, no authentication required (default)
          * `force_unauthorized` - Port blocks all traffic regardless of authentication
          * `auto` - Standard 802.1X authentication required before port access is granted
          * `mac_based` - Authentication based on client MAC address, useful for devices that don't support 802.1X
          * `multi_host` - Allows multiple devices after first successful authentication, common in VoIP phone setups

        Use 'auto' for highest security, 'mac_based' for legacy devices, and 'multi_host' when daisy-chaining devices.
        """
        return pulumi.get(self, "dot1x_ctrl")

    @dot1x_ctrl.setter
    def dot1x_ctrl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dot1x_ctrl", value)

    @_builtins.property
    @pulumi.getter(name="dot1xIdleTimeout")
    def dot1x_idle_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds before an inactive authenticated MAC address is removed when using MAC-based 802.1X control. Range: 0-65535 seconds.
        """
        return pulumi.get(self, "dot1x_idle_timeout")

    @dot1x_idle_timeout.setter
    def dot1x_idle_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "dot1x_idle_timeout", value)

    @_builtins.property
    @pulumi.getter(name="egressRateLimitKbps")
    def egress_rate_limit_kbps(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum outbound bandwidth allowed on the port in kilobits per second. Range: 64-9999999 kbps. Only applied when egress_rate_limit_kbps_enabled is true.
        """
        return pulumi.get(self, "egress_rate_limit_kbps")

    @egress_rate_limit_kbps.setter
    def egress_rate_limit_kbps(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "egress_rate_limit_kbps", value)

    @_builtins.property
    @pulumi.getter(name="egressRateLimitKbpsEnabled")
    def egress_rate_limit_kbps_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable outbound bandwidth rate limiting on the port. When enabled, traffic will be limited to the rate specified in egress_rate_limit_kbps.
        """
        return pulumi.get(self, "egress_rate_limit_kbps_enabled")

    @egress_rate_limit_kbps_enabled.setter
    def egress_rate_limit_kbps_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "egress_rate_limit_kbps_enabled", value)

    @_builtins.property
    @pulumi.getter(name="excludedNetworkIds")
    def excluded_network_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of network IDs to exclude when forward is set to 'customize'. This allows you to prevent specific networks from being accessible on ports using this profile.
        """
        return pulumi.get(self, "excluded_network_ids")

    @excluded_network_ids.setter
    def excluded_network_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_network_ids", value)

    @_builtins.property
    @pulumi.getter
    def forward(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        VLAN forwarding mode for the port. Valid values are:
          * `all` - Forward all VLANs (trunk port)
          * `native` - Only forward untagged traffic (access port)
          * `customize` - Forward selected VLANs (use with `excluded_network_ids`)
          * `disabled` - Disable VLAN forwarding

        Examples:
          * Use 'all' for uplink ports or connections to VLAN-aware devices
          * Use 'native' for end-user devices or simple network connections
          * Use 'customize' to create a selective trunk port (e.g., for a server needing access to specific VLANs)
        """
        return pulumi.get(self, "forward")

    @forward.setter
    def forward(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "forward", value)

    @_builtins.property
    @pulumi.getter(name="fullDuplex")
    def full_duplex(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable full-duplex mode when auto-negotiation is disabled. Full duplex allows simultaneous two-way communication.
        """
        return pulumi.get(self, "full_duplex")

    @full_duplex.setter
    def full_duplex(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "full_duplex", value)

    @_builtins.property
    @pulumi.getter
    def isolation(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable port isolation. When enabled, devices connected to ports with this profile cannot communicate with each other, providing enhanced security.
        """
        return pulumi.get(self, "isolation")

    @isolation.setter
    def isolation(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "isolation", value)

    @_builtins.property
    @pulumi.getter(name="lldpmedEnabled")
    def lldpmed_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable Link Layer Discovery Protocol-Media Endpoint Discovery (LLDP-MED). This allows for automatic discovery and configuration of devices like VoIP phones.
        """
        return pulumi.get(self, "lldpmed_enabled")

    @lldpmed_enabled.setter
    def lldpmed_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "lldpmed_enabled", value)

    @_builtins.property
    @pulumi.getter(name="lldpmedNotifyEnabled")
    def lldpmed_notify_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable LLDP-MED topology change notifications. When enabled:
        * Network devices will be notified of topology changes
        * Useful for VoIP phones and other LLDP-MED capable devices
        * Helps maintain accurate network topology information
        * Facilitates faster device configuration and provisioning
        """
        return pulumi.get(self, "lldpmed_notify_enabled")

    @lldpmed_notify_enabled.setter
    def lldpmed_notify_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "lldpmed_notify_enabled", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A descriptive name for the port profile. Examples:
        * 'AP-Trunk-Port' - For access point uplinks
        * 'VoIP-Phone-Port' - For VoIP phone connections
        * 'User-Access-Port' - For standard user connections
        * 'IoT-Device-Port' - For IoT device connections
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="nativeNetworkconfId")
    def native_networkconf_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the network to use as the native (untagged) network on ports using this profile. This is typically used for:
        * Access ports where devices need untagged access
        * Trunk ports to specify the native VLAN
        * Management networks for network devices
        """
        return pulumi.get(self, "native_networkconf_id")

    @native_networkconf_id.setter
    def native_networkconf_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "native_networkconf_id", value)

    @_builtins.property
    @pulumi.getter(name="opMode")
    def op_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The operation mode for the port profile. Can only be `switch`
        """
        return pulumi.get(self, "op_mode")

    @op_mode.setter
    def op_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "op_mode", value)

    @_builtins.property
    @pulumi.getter(name="poeMode")
    def poe_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The POE mode for the port profile. Can be one of `auto`, `passv24`, `passthrough` or `off`.
        """
        return pulumi.get(self, "poe_mode")

    @poe_mode.setter
    def poe_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "poe_mode", value)

    @_builtins.property
    @pulumi.getter(name="portSecurityEnabled")
    def port_security_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable MAC address-based port security. When enabled:
        * Only devices with specified MAC addresses can connect
        * Unauthorized devices will be blocked
        * Provides protection against unauthorized network access
        * Must be used with port_security_mac_address list
        """
        return pulumi.get(self, "port_security_enabled")

    @port_security_enabled.setter
    def port_security_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "port_security_enabled", value)

    @_builtins.property
    @pulumi.getter(name="portSecurityMacAddresses")
    def port_security_mac_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of allowed MAC addresses when port security is enabled. Each address should be:
        * In standard format (e.g., 'aa:bb:cc:dd:ee:ff')
        * Unique per device
        * Verified to belong to authorized devices
        Only effective when port_security_enabled is true
        """
        return pulumi.get(self, "port_security_mac_addresses")

    @port_security_mac_addresses.setter
    def port_security_mac_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "port_security_mac_addresses", value)

    @_builtins.property
    @pulumi.getter(name="priorityQueue1Level")
    def priority_queue1_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Priority queue 1 level (0-100) for Quality of Service (QoS). Used for:
        * Low-priority background traffic
        * Bulk data transfers
        * Non-time-sensitive applications
        Higher values give more bandwidth to this queue
        """
        return pulumi.get(self, "priority_queue1_level")

    @priority_queue1_level.setter
    def priority_queue1_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority_queue1_level", value)

    @_builtins.property
    @pulumi.getter(name="priorityQueue2Level")
    def priority_queue2_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Priority queue 2 level (0-100) for Quality of Service (QoS). Used for:
        * Standard user traffic
        * Web browsing and email
        * General business applications
        Higher values give more bandwidth to this queue
        """
        return pulumi.get(self, "priority_queue2_level")

    @priority_queue2_level.setter
    def priority_queue2_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority_queue2_level", value)

    @_builtins.property
    @pulumi.getter(name="priorityQueue3Level")
    def priority_queue3_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Priority queue 3 level (0-100) for Quality of Service (QoS). Used for:
        * High-priority traffic
        * Voice and video conferencing
        * Time-sensitive applications
        Higher values give more bandwidth to this queue
        """
        return pulumi.get(self, "priority_queue3_level")

    @priority_queue3_level.setter
    def priority_queue3_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority_queue3_level", value)

    @_builtins.property
    @pulumi.getter(name="priorityQueue4Level")
    def priority_queue4_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Priority queue 4 level (0-100) for Quality of Service (QoS). Used for:
        * Highest priority traffic
        * Critical real-time applications
        * Emergency communications
        Higher values give more bandwidth to this queue
        """
        return pulumi.get(self, "priority_queue4_level")

    @priority_queue4_level.setter
    def priority_queue4_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority_queue4_level", value)

    @_builtins.property
    @pulumi.getter
    def site(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the UniFi site where the port profile should be created. If not specified, the default site will be used.
        """
        return pulumi.get(self, "site")

    @site.setter
    def site(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "site", value)

    @_builtins.property
    @pulumi.getter
    def speed(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port speed in Mbps when auto-negotiation is disabled. Common values:
        * 10 - 10 Mbps (legacy devices)
        * 100 - 100 Mbps (Fast Ethernet)
        * 1000 - 1 Gbps (Gigabit Ethernet)
        * 2500 - 2.5 Gbps (Multi-Gigabit)
        * 5000 - 5 Gbps (Multi-Gigabit)
        * 10000 - 10 Gbps (10 Gigabit)
        Only used when autoneg is false
        """
        return pulumi.get(self, "speed")

    @speed.setter
    def speed(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "speed", value)

    @_builtins.property
    @pulumi.getter(name="stormctrlBcastEnabled")
    def stormctrl_bcast_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable broadcast storm control. When enabled:
        * Limits broadcast traffic to prevent network flooding
        * Protects against broadcast storms
        * Helps maintain network stability
        Use with stormctrl_bcast_rate to set threshold
        """
        return pulumi.get(self, "stormctrl_bcast_enabled")

    @stormctrl_bcast_enabled.setter
    def stormctrl_bcast_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "stormctrl_bcast_enabled", value)

    @_builtins.property
    @pulumi.getter(name="stormctrlBcastLevel")
    def stormctrl_bcast_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The broadcast Storm Control level for the port profile. Can be between 0 and 100.
        """
        return pulumi.get(self, "stormctrl_bcast_level")

    @stormctrl_bcast_level.setter
    def stormctrl_bcast_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "stormctrl_bcast_level", value)

    @_builtins.property
    @pulumi.getter(name="stormctrlBcastRate")
    def stormctrl_bcast_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum broadcast traffic rate in packets per second (0 - 14880000). Used to:
        * Control broadcast traffic levels
        * Prevent network congestion
        * Balance between necessary broadcasts and network protection
        Only effective when `stormctrl_bcast_enabled` is true
        """
        return pulumi.get(self, "stormctrl_bcast_rate")

    @stormctrl_bcast_rate.setter
    def stormctrl_bcast_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "stormctrl_bcast_rate", value)

    @_builtins.property
    @pulumi.getter(name="stormctrlMcastEnabled")
    def stormctrl_mcast_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable multicast storm control. When enabled:
        * Limits multicast traffic to prevent network flooding
        * Important for networks with multicast applications
        * Helps maintain quality of service
        Use with `stormctrl_mcast_rate` to set threshold
        """
        return pulumi.get(self, "stormctrl_mcast_enabled")

    @stormctrl_mcast_enabled.setter
    def stormctrl_mcast_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "stormctrl_mcast_enabled", value)

    @_builtins.property
    @pulumi.getter(name="stormctrlMcastLevel")
    def stormctrl_mcast_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The multicast Storm Control level for the port profile. Can be between 0 and 100.
        """
        return pulumi.get(self, "stormctrl_mcast_level")

    @stormctrl_mcast_level.setter
    def stormctrl_mcast_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "stormctrl_mcast_level", value)

    @_builtins.property
    @pulumi.getter(name="stormctrlMcastRate")
    def stormctrl_mcast_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum multicast traffic rate in packets per second (0 - 14880000). Used to:
        * Control multicast traffic levels
        * Ensure bandwidth for critical multicast services
        * Prevent multicast traffic from overwhelming the network
        Only effective when stormctrl_mcast_enabled is true
        """
        return pulumi.get(self, "stormctrl_mcast_rate")

    @stormctrl_mcast_rate.setter
    def stormctrl_mcast_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "stormctrl_mcast_rate", value)

    @_builtins.property
    @pulumi.getter(name="stormctrlType")
    def stormctrl_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of Storm Control to use for the port profile. Can be one of `level` or `rate`.
        """
        return pulumi.get(self, "stormctrl_type")

    @stormctrl_type.setter
    def stormctrl_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "stormctrl_type", value)

    @_builtins.property
    @pulumi.getter(name="stormctrlUcastEnabled")
    def stormctrl_ucast_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable unknown unicast storm control. When enabled:
        * Limits unknown unicast traffic to prevent flooding
        * Protects against MAC spoofing attacks
        * Helps maintain network performance
        Use with stormctrl_ucast_rate to set threshold
        """
        return pulumi.get(self, "stormctrl_ucast_enabled")

    @stormctrl_ucast_enabled.setter
    def stormctrl_ucast_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "stormctrl_ucast_enabled", value)

    @_builtins.property
    @pulumi.getter(name="stormctrlUcastLevel")
    def stormctrl_ucast_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The unknown unicast Storm Control level for the port profile. Can be between 0 and 100.
        """
        return pulumi.get(self, "stormctrl_ucast_level")

    @stormctrl_ucast_level.setter
    def stormctrl_ucast_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "stormctrl_ucast_level", value)

    @_builtins.property
    @pulumi.getter(name="stormctrlUcastRate")
    def stormctrl_ucast_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum unknown unicast traffic rate in packets per second (0 - 14880000). Used to:
        * Control unknown unicast traffic levels
        * Prevent network saturation from unknown destinations
        * Balance security with network usability
        Only effective when stormctrl_ucast_enabled is true
        """
        return pulumi.get(self, "stormctrl_ucast_rate")

    @stormctrl_ucast_rate.setter
    def stormctrl_ucast_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "stormctrl_ucast_rate", value)

    @_builtins.property
    @pulumi.getter(name="stpPortMode")
    def stp_port_mode(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Spanning Tree Protocol (STP) configuration for the port. When enabled:
        * Prevents network loops in switch-to-switch connections
        * Provides automatic failover in redundant topologies
        * Helps maintain network stability

        Best practices:
        * Enable on switch uplink ports
        * Enable on ports connecting to other switches
        * Can be disabled on end-device ports for faster initialization
        """
        return pulumi.get(self, "stp_port_mode")

    @stp_port_mode.setter
    def stp_port_mode(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "stp_port_mode", value)

    @_builtins.property
    @pulumi.getter(name="taggedVlanMgmt")
    def tagged_vlan_mgmt(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        VLAN tagging behavior for the port. Valid values are:
        * `auto` - Automatically handle VLAN tags (recommended)
            - Intelligently manages tagged and untagged traffic
            - Best for most deployments
        * `block_all` - Block all VLAN tagged traffic
            - Use for security-sensitive ports
            - Prevents VLAN hopping attacks
        * `custom` - Custom VLAN configuration
            - Manual control over VLAN behavior
            - For specific VLAN requirements
        """
        return pulumi.get(self, "tagged_vlan_mgmt")

    @tagged_vlan_mgmt.setter
    def tagged_vlan_mgmt(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tagged_vlan_mgmt", value)

    @_builtins.property
    @pulumi.getter(name="voiceNetworkconfId")
    def voice_networkconf_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the network to use for Voice over IP (VoIP) traffic. Used for:
        * Automatic VoIP VLAN configuration
        * Voice traffic prioritization
        * QoS settings for voice packets

        Common scenarios:
        * IP phone deployments with separate voice VLAN
        * Unified communications systems
        * Converged voice/data networks

        Works in conjunction with LLDP-MED for automatic phone provisioning.
        """
        return pulumi.get(self, "voice_networkconf_id")

    @voice_networkconf_id.setter
    def voice_networkconf_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "voice_networkconf_id", value)


@pulumi.type_token("unifi:port/profile:Profile")
class Profile(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 autoneg: Optional[pulumi.Input[_builtins.bool]] = None,
                 dot1x_ctrl: Optional[pulumi.Input[_builtins.str]] = None,
                 dot1x_idle_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 egress_rate_limit_kbps: Optional[pulumi.Input[_builtins.int]] = None,
                 egress_rate_limit_kbps_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 excluded_network_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 forward: Optional[pulumi.Input[_builtins.str]] = None,
                 full_duplex: Optional[pulumi.Input[_builtins.bool]] = None,
                 isolation: Optional[pulumi.Input[_builtins.bool]] = None,
                 lldpmed_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 lldpmed_notify_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 native_networkconf_id: Optional[pulumi.Input[_builtins.str]] = None,
                 op_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 poe_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 port_security_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 port_security_mac_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 priority_queue1_level: Optional[pulumi.Input[_builtins.int]] = None,
                 priority_queue2_level: Optional[pulumi.Input[_builtins.int]] = None,
                 priority_queue3_level: Optional[pulumi.Input[_builtins.int]] = None,
                 priority_queue4_level: Optional[pulumi.Input[_builtins.int]] = None,
                 site: Optional[pulumi.Input[_builtins.str]] = None,
                 speed: Optional[pulumi.Input[_builtins.int]] = None,
                 stormctrl_bcast_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 stormctrl_bcast_level: Optional[pulumi.Input[_builtins.int]] = None,
                 stormctrl_bcast_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 stormctrl_mcast_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 stormctrl_mcast_level: Optional[pulumi.Input[_builtins.int]] = None,
                 stormctrl_mcast_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 stormctrl_type: Optional[pulumi.Input[_builtins.str]] = None,
                 stormctrl_ucast_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 stormctrl_ucast_level: Optional[pulumi.Input[_builtins.int]] = None,
                 stormctrl_ucast_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 stp_port_mode: Optional[pulumi.Input[_builtins.bool]] = None,
                 tagged_vlan_mgmt: Optional[pulumi.Input[_builtins.str]] = None,
                 voice_networkconf_id: Optional[pulumi.Input[_builtins.str]] = None,
                 __props__=None):
        """
        The `port.Profile` resource manages port profiles that can be applied to UniFi switch ports.

        Port profiles define a collection of settings that can be applied to one or more switch ports, including:
          * Network and VLAN settings
          * Port speed and duplex settings
          * Security features like 802.1X authentication and port isolation
          * Rate limiting and QoS settings
          * Network protocols like LLDP and STP

        Creating port profiles allows for consistent configuration across multiple switch ports and easier management of port settings.

        ## Example Usage

        ```python
        import pulumi
        import pulumiverse_unifi as unifi

        config = pulumi.Config()
        vlan_id = config.get_float("vlanId")
        if vlan_id is None:
            vlan_id = 10
        vlan = unifi.Network("vlan",
            name="wifi-vlan",
            purpose="corporate",
            subnet="10.0.0.1/24",
            vlan_id=vlan_id,
            dhcp_start="10.0.0.6",
            dhcp_stop="10.0.0.254",
            dhcp_enabled=True)
        poe_disabled = unifi.port.Profile("poe_disabled",
            name="POE Disabled",
            native_networkconf_id=vlan.id,
            poe_mode="off")
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.bool] autoneg: Enable automatic negotiation of port speed and duplex settings. When enabled, this overrides manual speed and duplex settings. Recommended for most use cases.
        :param pulumi.Input[_builtins.str] dot1x_ctrl: 802.1X port-based network access control (PNAC) mode. Valid values are:
                 * `force_authorized` - Port allows all traffic, no authentication required (default)
                 * `force_unauthorized` - Port blocks all traffic regardless of authentication
                 * `auto` - Standard 802.1X authentication required before port access is granted
                 * `mac_based` - Authentication based on client MAC address, useful for devices that don't support 802.1X
                 * `multi_host` - Allows multiple devices after first successful authentication, common in VoIP phone setups
               
               Use 'auto' for highest security, 'mac_based' for legacy devices, and 'multi_host' when daisy-chaining devices.
        :param pulumi.Input[_builtins.int] dot1x_idle_timeout: The number of seconds before an inactive authenticated MAC address is removed when using MAC-based 802.1X control. Range: 0-65535 seconds.
        :param pulumi.Input[_builtins.int] egress_rate_limit_kbps: The maximum outbound bandwidth allowed on the port in kilobits per second. Range: 64-9999999 kbps. Only applied when egress_rate_limit_kbps_enabled is true.
        :param pulumi.Input[_builtins.bool] egress_rate_limit_kbps_enabled: Enable outbound bandwidth rate limiting on the port. When enabled, traffic will be limited to the rate specified in egress_rate_limit_kbps.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] excluded_network_ids: List of network IDs to exclude when forward is set to 'customize'. This allows you to prevent specific networks from being accessible on ports using this profile.
        :param pulumi.Input[_builtins.str] forward: VLAN forwarding mode for the port. Valid values are:
                 * `all` - Forward all VLANs (trunk port)
                 * `native` - Only forward untagged traffic (access port)
                 * `customize` - Forward selected VLANs (use with `excluded_network_ids`)
                 * `disabled` - Disable VLAN forwarding
               
               Examples:
                 * Use 'all' for uplink ports or connections to VLAN-aware devices
                 * Use 'native' for end-user devices or simple network connections
                 * Use 'customize' to create a selective trunk port (e.g., for a server needing access to specific VLANs)
        :param pulumi.Input[_builtins.bool] full_duplex: Enable full-duplex mode when auto-negotiation is disabled. Full duplex allows simultaneous two-way communication.
        :param pulumi.Input[_builtins.bool] isolation: Enable port isolation. When enabled, devices connected to ports with this profile cannot communicate with each other, providing enhanced security.
        :param pulumi.Input[_builtins.bool] lldpmed_enabled: Enable Link Layer Discovery Protocol-Media Endpoint Discovery (LLDP-MED). This allows for automatic discovery and configuration of devices like VoIP phones.
        :param pulumi.Input[_builtins.bool] lldpmed_notify_enabled: Enable LLDP-MED topology change notifications. When enabled:
               * Network devices will be notified of topology changes
               * Useful for VoIP phones and other LLDP-MED capable devices
               * Helps maintain accurate network topology information
               * Facilitates faster device configuration and provisioning
        :param pulumi.Input[_builtins.str] name: A descriptive name for the port profile. Examples:
               * 'AP-Trunk-Port' - For access point uplinks
               * 'VoIP-Phone-Port' - For VoIP phone connections
               * 'User-Access-Port' - For standard user connections
               * 'IoT-Device-Port' - For IoT device connections
        :param pulumi.Input[_builtins.str] native_networkconf_id: The ID of the network to use as the native (untagged) network on ports using this profile. This is typically used for:
               * Access ports where devices need untagged access
               * Trunk ports to specify the native VLAN
               * Management networks for network devices
        :param pulumi.Input[_builtins.str] op_mode: The operation mode for the port profile. Can only be `switch`
        :param pulumi.Input[_builtins.str] poe_mode: The POE mode for the port profile. Can be one of `auto`, `passv24`, `passthrough` or `off`.
        :param pulumi.Input[_builtins.bool] port_security_enabled: Enable MAC address-based port security. When enabled:
               * Only devices with specified MAC addresses can connect
               * Unauthorized devices will be blocked
               * Provides protection against unauthorized network access
               * Must be used with port_security_mac_address list
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] port_security_mac_addresses: List of allowed MAC addresses when port security is enabled. Each address should be:
               * In standard format (e.g., 'aa:bb:cc:dd:ee:ff')
               * Unique per device
               * Verified to belong to authorized devices
               Only effective when port_security_enabled is true
        :param pulumi.Input[_builtins.int] priority_queue1_level: Priority queue 1 level (0-100) for Quality of Service (QoS). Used for:
               * Low-priority background traffic
               * Bulk data transfers
               * Non-time-sensitive applications
               Higher values give more bandwidth to this queue
        :param pulumi.Input[_builtins.int] priority_queue2_level: Priority queue 2 level (0-100) for Quality of Service (QoS). Used for:
               * Standard user traffic
               * Web browsing and email
               * General business applications
               Higher values give more bandwidth to this queue
        :param pulumi.Input[_builtins.int] priority_queue3_level: Priority queue 3 level (0-100) for Quality of Service (QoS). Used for:
               * High-priority traffic
               * Voice and video conferencing
               * Time-sensitive applications
               Higher values give more bandwidth to this queue
        :param pulumi.Input[_builtins.int] priority_queue4_level: Priority queue 4 level (0-100) for Quality of Service (QoS). Used for:
               * Highest priority traffic
               * Critical real-time applications
               * Emergency communications
               Higher values give more bandwidth to this queue
        :param pulumi.Input[_builtins.str] site: The name of the UniFi site where the port profile should be created. If not specified, the default site will be used.
        :param pulumi.Input[_builtins.int] speed: Port speed in Mbps when auto-negotiation is disabled. Common values:
               * 10 - 10 Mbps (legacy devices)
               * 100 - 100 Mbps (Fast Ethernet)
               * 1000 - 1 Gbps (Gigabit Ethernet)
               * 2500 - 2.5 Gbps (Multi-Gigabit)
               * 5000 - 5 Gbps (Multi-Gigabit)
               * 10000 - 10 Gbps (10 Gigabit)
               Only used when autoneg is false
        :param pulumi.Input[_builtins.bool] stormctrl_bcast_enabled: Enable broadcast storm control. When enabled:
               * Limits broadcast traffic to prevent network flooding
               * Protects against broadcast storms
               * Helps maintain network stability
               Use with stormctrl_bcast_rate to set threshold
        :param pulumi.Input[_builtins.int] stormctrl_bcast_level: The broadcast Storm Control level for the port profile. Can be between 0 and 100.
        :param pulumi.Input[_builtins.int] stormctrl_bcast_rate: Maximum broadcast traffic rate in packets per second (0 - 14880000). Used to:
               * Control broadcast traffic levels
               * Prevent network congestion
               * Balance between necessary broadcasts and network protection
               Only effective when `stormctrl_bcast_enabled` is true
        :param pulumi.Input[_builtins.bool] stormctrl_mcast_enabled: Enable multicast storm control. When enabled:
               * Limits multicast traffic to prevent network flooding
               * Important for networks with multicast applications
               * Helps maintain quality of service
               Use with `stormctrl_mcast_rate` to set threshold
        :param pulumi.Input[_builtins.int] stormctrl_mcast_level: The multicast Storm Control level for the port profile. Can be between 0 and 100.
        :param pulumi.Input[_builtins.int] stormctrl_mcast_rate: Maximum multicast traffic rate in packets per second (0 - 14880000). Used to:
               * Control multicast traffic levels
               * Ensure bandwidth for critical multicast services
               * Prevent multicast traffic from overwhelming the network
               Only effective when stormctrl_mcast_enabled is true
        :param pulumi.Input[_builtins.str] stormctrl_type: The type of Storm Control to use for the port profile. Can be one of `level` or `rate`.
        :param pulumi.Input[_builtins.bool] stormctrl_ucast_enabled: Enable unknown unicast storm control. When enabled:
               * Limits unknown unicast traffic to prevent flooding
               * Protects against MAC spoofing attacks
               * Helps maintain network performance
               Use with stormctrl_ucast_rate to set threshold
        :param pulumi.Input[_builtins.int] stormctrl_ucast_level: The unknown unicast Storm Control level for the port profile. Can be between 0 and 100.
        :param pulumi.Input[_builtins.int] stormctrl_ucast_rate: Maximum unknown unicast traffic rate in packets per second (0 - 14880000). Used to:
               * Control unknown unicast traffic levels
               * Prevent network saturation from unknown destinations
               * Balance security with network usability
               Only effective when stormctrl_ucast_enabled is true
        :param pulumi.Input[_builtins.bool] stp_port_mode: Spanning Tree Protocol (STP) configuration for the port. When enabled:
               * Prevents network loops in switch-to-switch connections
               * Provides automatic failover in redundant topologies
               * Helps maintain network stability
               
               Best practices:
               * Enable on switch uplink ports
               * Enable on ports connecting to other switches
               * Can be disabled on end-device ports for faster initialization
        :param pulumi.Input[_builtins.str] tagged_vlan_mgmt: VLAN tagging behavior for the port. Valid values are:
               * `auto` - Automatically handle VLAN tags (recommended)
                   - Intelligently manages tagged and untagged traffic
                   - Best for most deployments
               * `block_all` - Block all VLAN tagged traffic
                   - Use for security-sensitive ports
                   - Prevents VLAN hopping attacks
               * `custom` - Custom VLAN configuration
                   - Manual control over VLAN behavior
                   - For specific VLAN requirements
        :param pulumi.Input[_builtins.str] voice_networkconf_id: The ID of the network to use for Voice over IP (VoIP) traffic. Used for:
               * Automatic VoIP VLAN configuration
               * Voice traffic prioritization
               * QoS settings for voice packets
               
               Common scenarios:
               * IP phone deployments with separate voice VLAN
               * Unified communications systems
               * Converged voice/data networks
               
               Works in conjunction with LLDP-MED for automatic phone provisioning.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: Optional[ProfileArgs] = None,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        The `port.Profile` resource manages port profiles that can be applied to UniFi switch ports.

        Port profiles define a collection of settings that can be applied to one or more switch ports, including:
          * Network and VLAN settings
          * Port speed and duplex settings
          * Security features like 802.1X authentication and port isolation
          * Rate limiting and QoS settings
          * Network protocols like LLDP and STP

        Creating port profiles allows for consistent configuration across multiple switch ports and easier management of port settings.

        ## Example Usage

        ```python
        import pulumi
        import pulumiverse_unifi as unifi

        config = pulumi.Config()
        vlan_id = config.get_float("vlanId")
        if vlan_id is None:
            vlan_id = 10
        vlan = unifi.Network("vlan",
            name="wifi-vlan",
            purpose="corporate",
            subnet="10.0.0.1/24",
            vlan_id=vlan_id,
            dhcp_start="10.0.0.6",
            dhcp_stop="10.0.0.254",
            dhcp_enabled=True)
        poe_disabled = unifi.port.Profile("poe_disabled",
            name="POE Disabled",
            native_networkconf_id=vlan.id,
            poe_mode="off")
        ```

        :param str resource_name: The name of the resource.
        :param ProfileArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(ProfileArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 autoneg: Optional[pulumi.Input[_builtins.bool]] = None,
                 dot1x_ctrl: Optional[pulumi.Input[_builtins.str]] = None,
                 dot1x_idle_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 egress_rate_limit_kbps: Optional[pulumi.Input[_builtins.int]] = None,
                 egress_rate_limit_kbps_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 excluded_network_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 forward: Optional[pulumi.Input[_builtins.str]] = None,
                 full_duplex: Optional[pulumi.Input[_builtins.bool]] = None,
                 isolation: Optional[pulumi.Input[_builtins.bool]] = None,
                 lldpmed_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 lldpmed_notify_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 native_networkconf_id: Optional[pulumi.Input[_builtins.str]] = None,
                 op_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 poe_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 port_security_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 port_security_mac_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 priority_queue1_level: Optional[pulumi.Input[_builtins.int]] = None,
                 priority_queue2_level: Optional[pulumi.Input[_builtins.int]] = None,
                 priority_queue3_level: Optional[pulumi.Input[_builtins.int]] = None,
                 priority_queue4_level: Optional[pulumi.Input[_builtins.int]] = None,
                 site: Optional[pulumi.Input[_builtins.str]] = None,
                 speed: Optional[pulumi.Input[_builtins.int]] = None,
                 stormctrl_bcast_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 stormctrl_bcast_level: Optional[pulumi.Input[_builtins.int]] = None,
                 stormctrl_bcast_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 stormctrl_mcast_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 stormctrl_mcast_level: Optional[pulumi.Input[_builtins.int]] = None,
                 stormctrl_mcast_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 stormctrl_type: Optional[pulumi.Input[_builtins.str]] = None,
                 stormctrl_ucast_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 stormctrl_ucast_level: Optional[pulumi.Input[_builtins.int]] = None,
                 stormctrl_ucast_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 stp_port_mode: Optional[pulumi.Input[_builtins.bool]] = None,
                 tagged_vlan_mgmt: Optional[pulumi.Input[_builtins.str]] = None,
                 voice_networkconf_id: Optional[pulumi.Input[_builtins.str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = ProfileArgs.__new__(ProfileArgs)

            __props__.__dict__["autoneg"] = autoneg
            __props__.__dict__["dot1x_ctrl"] = dot1x_ctrl
            __props__.__dict__["dot1x_idle_timeout"] = dot1x_idle_timeout
            __props__.__dict__["egress_rate_limit_kbps"] = egress_rate_limit_kbps
            __props__.__dict__["egress_rate_limit_kbps_enabled"] = egress_rate_limit_kbps_enabled
            __props__.__dict__["excluded_network_ids"] = excluded_network_ids
            __props__.__dict__["forward"] = forward
            __props__.__dict__["full_duplex"] = full_duplex
            __props__.__dict__["isolation"] = isolation
            __props__.__dict__["lldpmed_enabled"] = lldpmed_enabled
            __props__.__dict__["lldpmed_notify_enabled"] = lldpmed_notify_enabled
            __props__.__dict__["name"] = name
            __props__.__dict__["native_networkconf_id"] = native_networkconf_id
            __props__.__dict__["op_mode"] = op_mode
            __props__.__dict__["poe_mode"] = poe_mode
            __props__.__dict__["port_security_enabled"] = port_security_enabled
            __props__.__dict__["port_security_mac_addresses"] = port_security_mac_addresses
            __props__.__dict__["priority_queue1_level"] = priority_queue1_level
            __props__.__dict__["priority_queue2_level"] = priority_queue2_level
            __props__.__dict__["priority_queue3_level"] = priority_queue3_level
            __props__.__dict__["priority_queue4_level"] = priority_queue4_level
            __props__.__dict__["site"] = site
            __props__.__dict__["speed"] = speed
            __props__.__dict__["stormctrl_bcast_enabled"] = stormctrl_bcast_enabled
            __props__.__dict__["stormctrl_bcast_level"] = stormctrl_bcast_level
            __props__.__dict__["stormctrl_bcast_rate"] = stormctrl_bcast_rate
            __props__.__dict__["stormctrl_mcast_enabled"] = stormctrl_mcast_enabled
            __props__.__dict__["stormctrl_mcast_level"] = stormctrl_mcast_level
            __props__.__dict__["stormctrl_mcast_rate"] = stormctrl_mcast_rate
            __props__.__dict__["stormctrl_type"] = stormctrl_type
            __props__.__dict__["stormctrl_ucast_enabled"] = stormctrl_ucast_enabled
            __props__.__dict__["stormctrl_ucast_level"] = stormctrl_ucast_level
            __props__.__dict__["stormctrl_ucast_rate"] = stormctrl_ucast_rate
            __props__.__dict__["stp_port_mode"] = stp_port_mode
            __props__.__dict__["tagged_vlan_mgmt"] = tagged_vlan_mgmt
            __props__.__dict__["voice_networkconf_id"] = voice_networkconf_id
        super(Profile, __self__).__init__(
            'unifi:port/profile:Profile',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            autoneg: Optional[pulumi.Input[_builtins.bool]] = None,
            dot1x_ctrl: Optional[pulumi.Input[_builtins.str]] = None,
            dot1x_idle_timeout: Optional[pulumi.Input[_builtins.int]] = None,
            egress_rate_limit_kbps: Optional[pulumi.Input[_builtins.int]] = None,
            egress_rate_limit_kbps_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
            excluded_network_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            forward: Optional[pulumi.Input[_builtins.str]] = None,
            full_duplex: Optional[pulumi.Input[_builtins.bool]] = None,
            isolation: Optional[pulumi.Input[_builtins.bool]] = None,
            lldpmed_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
            lldpmed_notify_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
            name: Optional[pulumi.Input[_builtins.str]] = None,
            native_networkconf_id: Optional[pulumi.Input[_builtins.str]] = None,
            op_mode: Optional[pulumi.Input[_builtins.str]] = None,
            poe_mode: Optional[pulumi.Input[_builtins.str]] = None,
            port_security_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
            port_security_mac_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            priority_queue1_level: Optional[pulumi.Input[_builtins.int]] = None,
            priority_queue2_level: Optional[pulumi.Input[_builtins.int]] = None,
            priority_queue3_level: Optional[pulumi.Input[_builtins.int]] = None,
            priority_queue4_level: Optional[pulumi.Input[_builtins.int]] = None,
            site: Optional[pulumi.Input[_builtins.str]] = None,
            speed: Optional[pulumi.Input[_builtins.int]] = None,
            stormctrl_bcast_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
            stormctrl_bcast_level: Optional[pulumi.Input[_builtins.int]] = None,
            stormctrl_bcast_rate: Optional[pulumi.Input[_builtins.int]] = None,
            stormctrl_mcast_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
            stormctrl_mcast_level: Optional[pulumi.Input[_builtins.int]] = None,
            stormctrl_mcast_rate: Optional[pulumi.Input[_builtins.int]] = None,
            stormctrl_type: Optional[pulumi.Input[_builtins.str]] = None,
            stormctrl_ucast_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
            stormctrl_ucast_level: Optional[pulumi.Input[_builtins.int]] = None,
            stormctrl_ucast_rate: Optional[pulumi.Input[_builtins.int]] = None,
            stp_port_mode: Optional[pulumi.Input[_builtins.bool]] = None,
            tagged_vlan_mgmt: Optional[pulumi.Input[_builtins.str]] = None,
            voice_networkconf_id: Optional[pulumi.Input[_builtins.str]] = None) -> 'Profile':
        """
        Get an existing Profile resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.bool] autoneg: Enable automatic negotiation of port speed and duplex settings. When enabled, this overrides manual speed and duplex settings. Recommended for most use cases.
        :param pulumi.Input[_builtins.str] dot1x_ctrl: 802.1X port-based network access control (PNAC) mode. Valid values are:
                 * `force_authorized` - Port allows all traffic, no authentication required (default)
                 * `force_unauthorized` - Port blocks all traffic regardless of authentication
                 * `auto` - Standard 802.1X authentication required before port access is granted
                 * `mac_based` - Authentication based on client MAC address, useful for devices that don't support 802.1X
                 * `multi_host` - Allows multiple devices after first successful authentication, common in VoIP phone setups
               
               Use 'auto' for highest security, 'mac_based' for legacy devices, and 'multi_host' when daisy-chaining devices.
        :param pulumi.Input[_builtins.int] dot1x_idle_timeout: The number of seconds before an inactive authenticated MAC address is removed when using MAC-based 802.1X control. Range: 0-65535 seconds.
        :param pulumi.Input[_builtins.int] egress_rate_limit_kbps: The maximum outbound bandwidth allowed on the port in kilobits per second. Range: 64-9999999 kbps. Only applied when egress_rate_limit_kbps_enabled is true.
        :param pulumi.Input[_builtins.bool] egress_rate_limit_kbps_enabled: Enable outbound bandwidth rate limiting on the port. When enabled, traffic will be limited to the rate specified in egress_rate_limit_kbps.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] excluded_network_ids: List of network IDs to exclude when forward is set to 'customize'. This allows you to prevent specific networks from being accessible on ports using this profile.
        :param pulumi.Input[_builtins.str] forward: VLAN forwarding mode for the port. Valid values are:
                 * `all` - Forward all VLANs (trunk port)
                 * `native` - Only forward untagged traffic (access port)
                 * `customize` - Forward selected VLANs (use with `excluded_network_ids`)
                 * `disabled` - Disable VLAN forwarding
               
               Examples:
                 * Use 'all' for uplink ports or connections to VLAN-aware devices
                 * Use 'native' for end-user devices or simple network connections
                 * Use 'customize' to create a selective trunk port (e.g., for a server needing access to specific VLANs)
        :param pulumi.Input[_builtins.bool] full_duplex: Enable full-duplex mode when auto-negotiation is disabled. Full duplex allows simultaneous two-way communication.
        :param pulumi.Input[_builtins.bool] isolation: Enable port isolation. When enabled, devices connected to ports with this profile cannot communicate with each other, providing enhanced security.
        :param pulumi.Input[_builtins.bool] lldpmed_enabled: Enable Link Layer Discovery Protocol-Media Endpoint Discovery (LLDP-MED). This allows for automatic discovery and configuration of devices like VoIP phones.
        :param pulumi.Input[_builtins.bool] lldpmed_notify_enabled: Enable LLDP-MED topology change notifications. When enabled:
               * Network devices will be notified of topology changes
               * Useful for VoIP phones and other LLDP-MED capable devices
               * Helps maintain accurate network topology information
               * Facilitates faster device configuration and provisioning
        :param pulumi.Input[_builtins.str] name: A descriptive name for the port profile. Examples:
               * 'AP-Trunk-Port' - For access point uplinks
               * 'VoIP-Phone-Port' - For VoIP phone connections
               * 'User-Access-Port' - For standard user connections
               * 'IoT-Device-Port' - For IoT device connections
        :param pulumi.Input[_builtins.str] native_networkconf_id: The ID of the network to use as the native (untagged) network on ports using this profile. This is typically used for:
               * Access ports where devices need untagged access
               * Trunk ports to specify the native VLAN
               * Management networks for network devices
        :param pulumi.Input[_builtins.str] op_mode: The operation mode for the port profile. Can only be `switch`
        :param pulumi.Input[_builtins.str] poe_mode: The POE mode for the port profile. Can be one of `auto`, `passv24`, `passthrough` or `off`.
        :param pulumi.Input[_builtins.bool] port_security_enabled: Enable MAC address-based port security. When enabled:
               * Only devices with specified MAC addresses can connect
               * Unauthorized devices will be blocked
               * Provides protection against unauthorized network access
               * Must be used with port_security_mac_address list
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] port_security_mac_addresses: List of allowed MAC addresses when port security is enabled. Each address should be:
               * In standard format (e.g., 'aa:bb:cc:dd:ee:ff')
               * Unique per device
               * Verified to belong to authorized devices
               Only effective when port_security_enabled is true
        :param pulumi.Input[_builtins.int] priority_queue1_level: Priority queue 1 level (0-100) for Quality of Service (QoS). Used for:
               * Low-priority background traffic
               * Bulk data transfers
               * Non-time-sensitive applications
               Higher values give more bandwidth to this queue
        :param pulumi.Input[_builtins.int] priority_queue2_level: Priority queue 2 level (0-100) for Quality of Service (QoS). Used for:
               * Standard user traffic
               * Web browsing and email
               * General business applications
               Higher values give more bandwidth to this queue
        :param pulumi.Input[_builtins.int] priority_queue3_level: Priority queue 3 level (0-100) for Quality of Service (QoS). Used for:
               * High-priority traffic
               * Voice and video conferencing
               * Time-sensitive applications
               Higher values give more bandwidth to this queue
        :param pulumi.Input[_builtins.int] priority_queue4_level: Priority queue 4 level (0-100) for Quality of Service (QoS). Used for:
               * Highest priority traffic
               * Critical real-time applications
               * Emergency communications
               Higher values give more bandwidth to this queue
        :param pulumi.Input[_builtins.str] site: The name of the UniFi site where the port profile should be created. If not specified, the default site will be used.
        :param pulumi.Input[_builtins.int] speed: Port speed in Mbps when auto-negotiation is disabled. Common values:
               * 10 - 10 Mbps (legacy devices)
               * 100 - 100 Mbps (Fast Ethernet)
               * 1000 - 1 Gbps (Gigabit Ethernet)
               * 2500 - 2.5 Gbps (Multi-Gigabit)
               * 5000 - 5 Gbps (Multi-Gigabit)
               * 10000 - 10 Gbps (10 Gigabit)
               Only used when autoneg is false
        :param pulumi.Input[_builtins.bool] stormctrl_bcast_enabled: Enable broadcast storm control. When enabled:
               * Limits broadcast traffic to prevent network flooding
               * Protects against broadcast storms
               * Helps maintain network stability
               Use with stormctrl_bcast_rate to set threshold
        :param pulumi.Input[_builtins.int] stormctrl_bcast_level: The broadcast Storm Control level for the port profile. Can be between 0 and 100.
        :param pulumi.Input[_builtins.int] stormctrl_bcast_rate: Maximum broadcast traffic rate in packets per second (0 - 14880000). Used to:
               * Control broadcast traffic levels
               * Prevent network congestion
               * Balance between necessary broadcasts and network protection
               Only effective when `stormctrl_bcast_enabled` is true
        :param pulumi.Input[_builtins.bool] stormctrl_mcast_enabled: Enable multicast storm control. When enabled:
               * Limits multicast traffic to prevent network flooding
               * Important for networks with multicast applications
               * Helps maintain quality of service
               Use with `stormctrl_mcast_rate` to set threshold
        :param pulumi.Input[_builtins.int] stormctrl_mcast_level: The multicast Storm Control level for the port profile. Can be between 0 and 100.
        :param pulumi.Input[_builtins.int] stormctrl_mcast_rate: Maximum multicast traffic rate in packets per second (0 - 14880000). Used to:
               * Control multicast traffic levels
               * Ensure bandwidth for critical multicast services
               * Prevent multicast traffic from overwhelming the network
               Only effective when stormctrl_mcast_enabled is true
        :param pulumi.Input[_builtins.str] stormctrl_type: The type of Storm Control to use for the port profile. Can be one of `level` or `rate`.
        :param pulumi.Input[_builtins.bool] stormctrl_ucast_enabled: Enable unknown unicast storm control. When enabled:
               * Limits unknown unicast traffic to prevent flooding
               * Protects against MAC spoofing attacks
               * Helps maintain network performance
               Use with stormctrl_ucast_rate to set threshold
        :param pulumi.Input[_builtins.int] stormctrl_ucast_level: The unknown unicast Storm Control level for the port profile. Can be between 0 and 100.
        :param pulumi.Input[_builtins.int] stormctrl_ucast_rate: Maximum unknown unicast traffic rate in packets per second (0 - 14880000). Used to:
               * Control unknown unicast traffic levels
               * Prevent network saturation from unknown destinations
               * Balance security with network usability
               Only effective when stormctrl_ucast_enabled is true
        :param pulumi.Input[_builtins.bool] stp_port_mode: Spanning Tree Protocol (STP) configuration for the port. When enabled:
               * Prevents network loops in switch-to-switch connections
               * Provides automatic failover in redundant topologies
               * Helps maintain network stability
               
               Best practices:
               * Enable on switch uplink ports
               * Enable on ports connecting to other switches
               * Can be disabled on end-device ports for faster initialization
        :param pulumi.Input[_builtins.str] tagged_vlan_mgmt: VLAN tagging behavior for the port. Valid values are:
               * `auto` - Automatically handle VLAN tags (recommended)
                   - Intelligently manages tagged and untagged traffic
                   - Best for most deployments
               * `block_all` - Block all VLAN tagged traffic
                   - Use for security-sensitive ports
                   - Prevents VLAN hopping attacks
               * `custom` - Custom VLAN configuration
                   - Manual control over VLAN behavior
                   - For specific VLAN requirements
        :param pulumi.Input[_builtins.str] voice_networkconf_id: The ID of the network to use for Voice over IP (VoIP) traffic. Used for:
               * Automatic VoIP VLAN configuration
               * Voice traffic prioritization
               * QoS settings for voice packets
               
               Common scenarios:
               * IP phone deployments with separate voice VLAN
               * Unified communications systems
               * Converged voice/data networks
               
               Works in conjunction with LLDP-MED for automatic phone provisioning.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _ProfileState.__new__(_ProfileState)

        __props__.__dict__["autoneg"] = autoneg
        __props__.__dict__["dot1x_ctrl"] = dot1x_ctrl
        __props__.__dict__["dot1x_idle_timeout"] = dot1x_idle_timeout
        __props__.__dict__["egress_rate_limit_kbps"] = egress_rate_limit_kbps
        __props__.__dict__["egress_rate_limit_kbps_enabled"] = egress_rate_limit_kbps_enabled
        __props__.__dict__["excluded_network_ids"] = excluded_network_ids
        __props__.__dict__["forward"] = forward
        __props__.__dict__["full_duplex"] = full_duplex
        __props__.__dict__["isolation"] = isolation
        __props__.__dict__["lldpmed_enabled"] = lldpmed_enabled
        __props__.__dict__["lldpmed_notify_enabled"] = lldpmed_notify_enabled
        __props__.__dict__["name"] = name
        __props__.__dict__["native_networkconf_id"] = native_networkconf_id
        __props__.__dict__["op_mode"] = op_mode
        __props__.__dict__["poe_mode"] = poe_mode
        __props__.__dict__["port_security_enabled"] = port_security_enabled
        __props__.__dict__["port_security_mac_addresses"] = port_security_mac_addresses
        __props__.__dict__["priority_queue1_level"] = priority_queue1_level
        __props__.__dict__["priority_queue2_level"] = priority_queue2_level
        __props__.__dict__["priority_queue3_level"] = priority_queue3_level
        __props__.__dict__["priority_queue4_level"] = priority_queue4_level
        __props__.__dict__["site"] = site
        __props__.__dict__["speed"] = speed
        __props__.__dict__["stormctrl_bcast_enabled"] = stormctrl_bcast_enabled
        __props__.__dict__["stormctrl_bcast_level"] = stormctrl_bcast_level
        __props__.__dict__["stormctrl_bcast_rate"] = stormctrl_bcast_rate
        __props__.__dict__["stormctrl_mcast_enabled"] = stormctrl_mcast_enabled
        __props__.__dict__["stormctrl_mcast_level"] = stormctrl_mcast_level
        __props__.__dict__["stormctrl_mcast_rate"] = stormctrl_mcast_rate
        __props__.__dict__["stormctrl_type"] = stormctrl_type
        __props__.__dict__["stormctrl_ucast_enabled"] = stormctrl_ucast_enabled
        __props__.__dict__["stormctrl_ucast_level"] = stormctrl_ucast_level
        __props__.__dict__["stormctrl_ucast_rate"] = stormctrl_ucast_rate
        __props__.__dict__["stp_port_mode"] = stp_port_mode
        __props__.__dict__["tagged_vlan_mgmt"] = tagged_vlan_mgmt
        __props__.__dict__["voice_networkconf_id"] = voice_networkconf_id
        return Profile(resource_name, opts=opts, __props__=__props__)

    @_builtins.property
    @pulumi.getter
    def autoneg(self) -> pulumi.Output[Optional[_builtins.bool]]:
        """
        Enable automatic negotiation of port speed and duplex settings. When enabled, this overrides manual speed and duplex settings. Recommended for most use cases.
        """
        return pulumi.get(self, "autoneg")

    @_builtins.property
    @pulumi.getter(name="dot1xCtrl")
    def dot1x_ctrl(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        802.1X port-based network access control (PNAC) mode. Valid values are:
          * `force_authorized` - Port allows all traffic, no authentication required (default)
          * `force_unauthorized` - Port blocks all traffic regardless of authentication
          * `auto` - Standard 802.1X authentication required before port access is granted
          * `mac_based` - Authentication based on client MAC address, useful for devices that don't support 802.1X
          * `multi_host` - Allows multiple devices after first successful authentication, common in VoIP phone setups

        Use 'auto' for highest security, 'mac_based' for legacy devices, and 'multi_host' when daisy-chaining devices.
        """
        return pulumi.get(self, "dot1x_ctrl")

    @_builtins.property
    @pulumi.getter(name="dot1xIdleTimeout")
    def dot1x_idle_timeout(self) -> pulumi.Output[Optional[_builtins.int]]:
        """
        The number of seconds before an inactive authenticated MAC address is removed when using MAC-based 802.1X control. Range: 0-65535 seconds.
        """
        return pulumi.get(self, "dot1x_idle_timeout")

    @_builtins.property
    @pulumi.getter(name="egressRateLimitKbps")
    def egress_rate_limit_kbps(self) -> pulumi.Output[Optional[_builtins.int]]:
        """
        The maximum outbound bandwidth allowed on the port in kilobits per second. Range: 64-9999999 kbps. Only applied when egress_rate_limit_kbps_enabled is true.
        """
        return pulumi.get(self, "egress_rate_limit_kbps")

    @_builtins.property
    @pulumi.getter(name="egressRateLimitKbpsEnabled")
    def egress_rate_limit_kbps_enabled(self) -> pulumi.Output[Optional[_builtins.bool]]:
        """
        Enable outbound bandwidth rate limiting on the port. When enabled, traffic will be limited to the rate specified in egress_rate_limit_kbps.
        """
        return pulumi.get(self, "egress_rate_limit_kbps_enabled")

    @_builtins.property
    @pulumi.getter(name="excludedNetworkIds")
    def excluded_network_ids(self) -> pulumi.Output[Optional[Sequence[_builtins.str]]]:
        """
        List of network IDs to exclude when forward is set to 'customize'. This allows you to prevent specific networks from being accessible on ports using this profile.
        """
        return pulumi.get(self, "excluded_network_ids")

    @_builtins.property
    @pulumi.getter
    def forward(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        VLAN forwarding mode for the port. Valid values are:
          * `all` - Forward all VLANs (trunk port)
          * `native` - Only forward untagged traffic (access port)
          * `customize` - Forward selected VLANs (use with `excluded_network_ids`)
          * `disabled` - Disable VLAN forwarding

        Examples:
          * Use 'all' for uplink ports or connections to VLAN-aware devices
          * Use 'native' for end-user devices or simple network connections
          * Use 'customize' to create a selective trunk port (e.g., for a server needing access to specific VLANs)
        """
        return pulumi.get(self, "forward")

    @_builtins.property
    @pulumi.getter(name="fullDuplex")
    def full_duplex(self) -> pulumi.Output[Optional[_builtins.bool]]:
        """
        Enable full-duplex mode when auto-negotiation is disabled. Full duplex allows simultaneous two-way communication.
        """
        return pulumi.get(self, "full_duplex")

    @_builtins.property
    @pulumi.getter
    def isolation(self) -> pulumi.Output[Optional[_builtins.bool]]:
        """
        Enable port isolation. When enabled, devices connected to ports with this profile cannot communicate with each other, providing enhanced security.
        """
        return pulumi.get(self, "isolation")

    @_builtins.property
    @pulumi.getter(name="lldpmedEnabled")
    def lldpmed_enabled(self) -> pulumi.Output[Optional[_builtins.bool]]:
        """
        Enable Link Layer Discovery Protocol-Media Endpoint Discovery (LLDP-MED). This allows for automatic discovery and configuration of devices like VoIP phones.
        """
        return pulumi.get(self, "lldpmed_enabled")

    @_builtins.property
    @pulumi.getter(name="lldpmedNotifyEnabled")
    def lldpmed_notify_enabled(self) -> pulumi.Output[Optional[_builtins.bool]]:
        """
        Enable LLDP-MED topology change notifications. When enabled:
        * Network devices will be notified of topology changes
        * Useful for VoIP phones and other LLDP-MED capable devices
        * Helps maintain accurate network topology information
        * Facilitates faster device configuration and provisioning
        """
        return pulumi.get(self, "lldpmed_notify_enabled")

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Output[_builtins.str]:
        """
        A descriptive name for the port profile. Examples:
        * 'AP-Trunk-Port' - For access point uplinks
        * 'VoIP-Phone-Port' - For VoIP phone connections
        * 'User-Access-Port' - For standard user connections
        * 'IoT-Device-Port' - For IoT device connections
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nativeNetworkconfId")
    def native_networkconf_id(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        The ID of the network to use as the native (untagged) network on ports using this profile. This is typically used for:
        * Access ports where devices need untagged access
        * Trunk ports to specify the native VLAN
        * Management networks for network devices
        """
        return pulumi.get(self, "native_networkconf_id")

    @_builtins.property
    @pulumi.getter(name="opMode")
    def op_mode(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        The operation mode for the port profile. Can only be `switch`
        """
        return pulumi.get(self, "op_mode")

    @_builtins.property
    @pulumi.getter(name="poeMode")
    def poe_mode(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        The POE mode for the port profile. Can be one of `auto`, `passv24`, `passthrough` or `off`.
        """
        return pulumi.get(self, "poe_mode")

    @_builtins.property
    @pulumi.getter(name="portSecurityEnabled")
    def port_security_enabled(self) -> pulumi.Output[Optional[_builtins.bool]]:
        """
        Enable MAC address-based port security. When enabled:
        * Only devices with specified MAC addresses can connect
        * Unauthorized devices will be blocked
        * Provides protection against unauthorized network access
        * Must be used with port_security_mac_address list
        """
        return pulumi.get(self, "port_security_enabled")

    @_builtins.property
    @pulumi.getter(name="portSecurityMacAddresses")
    def port_security_mac_addresses(self) -> pulumi.Output[Optional[Sequence[_builtins.str]]]:
        """
        List of allowed MAC addresses when port security is enabled. Each address should be:
        * In standard format (e.g., 'aa:bb:cc:dd:ee:ff')
        * Unique per device
        * Verified to belong to authorized devices
        Only effective when port_security_enabled is true
        """
        return pulumi.get(self, "port_security_mac_addresses")

    @_builtins.property
    @pulumi.getter(name="priorityQueue1Level")
    def priority_queue1_level(self) -> pulumi.Output[Optional[_builtins.int]]:
        """
        Priority queue 1 level (0-100) for Quality of Service (QoS). Used for:
        * Low-priority background traffic
        * Bulk data transfers
        * Non-time-sensitive applications
        Higher values give more bandwidth to this queue
        """
        return pulumi.get(self, "priority_queue1_level")

    @_builtins.property
    @pulumi.getter(name="priorityQueue2Level")
    def priority_queue2_level(self) -> pulumi.Output[Optional[_builtins.int]]:
        """
        Priority queue 2 level (0-100) for Quality of Service (QoS). Used for:
        * Standard user traffic
        * Web browsing and email
        * General business applications
        Higher values give more bandwidth to this queue
        """
        return pulumi.get(self, "priority_queue2_level")

    @_builtins.property
    @pulumi.getter(name="priorityQueue3Level")
    def priority_queue3_level(self) -> pulumi.Output[Optional[_builtins.int]]:
        """
        Priority queue 3 level (0-100) for Quality of Service (QoS). Used for:
        * High-priority traffic
        * Voice and video conferencing
        * Time-sensitive applications
        Higher values give more bandwidth to this queue
        """
        return pulumi.get(self, "priority_queue3_level")

    @_builtins.property
    @pulumi.getter(name="priorityQueue4Level")
    def priority_queue4_level(self) -> pulumi.Output[Optional[_builtins.int]]:
        """
        Priority queue 4 level (0-100) for Quality of Service (QoS). Used for:
        * Highest priority traffic
        * Critical real-time applications
        * Emergency communications
        Higher values give more bandwidth to this queue
        """
        return pulumi.get(self, "priority_queue4_level")

    @_builtins.property
    @pulumi.getter
    def site(self) -> pulumi.Output[_builtins.str]:
        """
        The name of the UniFi site where the port profile should be created. If not specified, the default site will be used.
        """
        return pulumi.get(self, "site")

    @_builtins.property
    @pulumi.getter
    def speed(self) -> pulumi.Output[Optional[_builtins.int]]:
        """
        Port speed in Mbps when auto-negotiation is disabled. Common values:
        * 10 - 10 Mbps (legacy devices)
        * 100 - 100 Mbps (Fast Ethernet)
        * 1000 - 1 Gbps (Gigabit Ethernet)
        * 2500 - 2.5 Gbps (Multi-Gigabit)
        * 5000 - 5 Gbps (Multi-Gigabit)
        * 10000 - 10 Gbps (10 Gigabit)
        Only used when autoneg is false
        """
        return pulumi.get(self, "speed")

    @_builtins.property
    @pulumi.getter(name="stormctrlBcastEnabled")
    def stormctrl_bcast_enabled(self) -> pulumi.Output[Optional[_builtins.bool]]:
        """
        Enable broadcast storm control. When enabled:
        * Limits broadcast traffic to prevent network flooding
        * Protects against broadcast storms
        * Helps maintain network stability
        Use with stormctrl_bcast_rate to set threshold
        """
        return pulumi.get(self, "stormctrl_bcast_enabled")

    @_builtins.property
    @pulumi.getter(name="stormctrlBcastLevel")
    def stormctrl_bcast_level(self) -> pulumi.Output[Optional[_builtins.int]]:
        """
        The broadcast Storm Control level for the port profile. Can be between 0 and 100.
        """
        return pulumi.get(self, "stormctrl_bcast_level")

    @_builtins.property
    @pulumi.getter(name="stormctrlBcastRate")
    def stormctrl_bcast_rate(self) -> pulumi.Output[Optional[_builtins.int]]:
        """
        Maximum broadcast traffic rate in packets per second (0 - 14880000). Used to:
        * Control broadcast traffic levels
        * Prevent network congestion
        * Balance between necessary broadcasts and network protection
        Only effective when `stormctrl_bcast_enabled` is true
        """
        return pulumi.get(self, "stormctrl_bcast_rate")

    @_builtins.property
    @pulumi.getter(name="stormctrlMcastEnabled")
    def stormctrl_mcast_enabled(self) -> pulumi.Output[Optional[_builtins.bool]]:
        """
        Enable multicast storm control. When enabled:
        * Limits multicast traffic to prevent network flooding
        * Important for networks with multicast applications
        * Helps maintain quality of service
        Use with `stormctrl_mcast_rate` to set threshold
        """
        return pulumi.get(self, "stormctrl_mcast_enabled")

    @_builtins.property
    @pulumi.getter(name="stormctrlMcastLevel")
    def stormctrl_mcast_level(self) -> pulumi.Output[Optional[_builtins.int]]:
        """
        The multicast Storm Control level for the port profile. Can be between 0 and 100.
        """
        return pulumi.get(self, "stormctrl_mcast_level")

    @_builtins.property
    @pulumi.getter(name="stormctrlMcastRate")
    def stormctrl_mcast_rate(self) -> pulumi.Output[Optional[_builtins.int]]:
        """
        Maximum multicast traffic rate in packets per second (0 - 14880000). Used to:
        * Control multicast traffic levels
        * Ensure bandwidth for critical multicast services
        * Prevent multicast traffic from overwhelming the network
        Only effective when stormctrl_mcast_enabled is true
        """
        return pulumi.get(self, "stormctrl_mcast_rate")

    @_builtins.property
    @pulumi.getter(name="stormctrlType")
    def stormctrl_type(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        The type of Storm Control to use for the port profile. Can be one of `level` or `rate`.
        """
        return pulumi.get(self, "stormctrl_type")

    @_builtins.property
    @pulumi.getter(name="stormctrlUcastEnabled")
    def stormctrl_ucast_enabled(self) -> pulumi.Output[Optional[_builtins.bool]]:
        """
        Enable unknown unicast storm control. When enabled:
        * Limits unknown unicast traffic to prevent flooding
        * Protects against MAC spoofing attacks
        * Helps maintain network performance
        Use with stormctrl_ucast_rate to set threshold
        """
        return pulumi.get(self, "stormctrl_ucast_enabled")

    @_builtins.property
    @pulumi.getter(name="stormctrlUcastLevel")
    def stormctrl_ucast_level(self) -> pulumi.Output[Optional[_builtins.int]]:
        """
        The unknown unicast Storm Control level for the port profile. Can be between 0 and 100.
        """
        return pulumi.get(self, "stormctrl_ucast_level")

    @_builtins.property
    @pulumi.getter(name="stormctrlUcastRate")
    def stormctrl_ucast_rate(self) -> pulumi.Output[Optional[_builtins.int]]:
        """
        Maximum unknown unicast traffic rate in packets per second (0 - 14880000). Used to:
        * Control unknown unicast traffic levels
        * Prevent network saturation from unknown destinations
        * Balance security with network usability
        Only effective when stormctrl_ucast_enabled is true
        """
        return pulumi.get(self, "stormctrl_ucast_rate")

    @_builtins.property
    @pulumi.getter(name="stpPortMode")
    def stp_port_mode(self) -> pulumi.Output[Optional[_builtins.bool]]:
        """
        Spanning Tree Protocol (STP) configuration for the port. When enabled:
        * Prevents network loops in switch-to-switch connections
        * Provides automatic failover in redundant topologies
        * Helps maintain network stability

        Best practices:
        * Enable on switch uplink ports
        * Enable on ports connecting to other switches
        * Can be disabled on end-device ports for faster initialization
        """
        return pulumi.get(self, "stp_port_mode")

    @_builtins.property
    @pulumi.getter(name="taggedVlanMgmt")
    def tagged_vlan_mgmt(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        VLAN tagging behavior for the port. Valid values are:
        * `auto` - Automatically handle VLAN tags (recommended)
            - Intelligently manages tagged and untagged traffic
            - Best for most deployments
        * `block_all` - Block all VLAN tagged traffic
            - Use for security-sensitive ports
            - Prevents VLAN hopping attacks
        * `custom` - Custom VLAN configuration
            - Manual control over VLAN behavior
            - For specific VLAN requirements
        """
        return pulumi.get(self, "tagged_vlan_mgmt")

    @_builtins.property
    @pulumi.getter(name="voiceNetworkconfId")
    def voice_networkconf_id(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        The ID of the network to use for Voice over IP (VoIP) traffic. Used for:
        * Automatic VoIP VLAN configuration
        * Voice traffic prioritization
        * QoS settings for voice packets

        Common scenarios:
        * IP phone deployments with separate voice VLAN
        * Unified communications systems
        * Converged voice/data networks

        Works in conjunction with LLDP-MED for automatic phone provisioning.
        """
        return pulumi.get(self, "voice_networkconf_id")

