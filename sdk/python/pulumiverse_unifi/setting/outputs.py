# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'GuestAccessAuthorize',
    'GuestAccessFacebook',
    'GuestAccessFacebookWifi',
    'GuestAccessGoogle',
    'GuestAccessIppay',
    'GuestAccessMerchantWarrior',
    'GuestAccessPaypal',
    'GuestAccessPortalCustomization',
    'GuestAccessQuickpay',
    'GuestAccessRadius',
    'GuestAccessRedirect',
    'GuestAccessStripe',
    'GuestAccessWechat',
    'IpsDnsFilter',
    'IpsHoneypot',
    'IpsSuppression',
    'IpsSuppressionAlert',
    'IpsSuppressionAlertTracking',
    'IpsSuppressionWhitelist',
    'MgmtSshKey',
    'USGDhcpRelay',
    'USGDnsVerification',
    'USGGeoIpFiltering',
    'USGTcpTimeouts',
    'USGUpnp',
]

@pulumi.output_type
class GuestAccessAuthorize(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loginId":
            suggest = "login_id"
        elif key == "transactionKey":
            suggest = "transaction_key"
        elif key == "useSandbox":
            suggest = "use_sandbox"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuestAccessAuthorize. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuestAccessAuthorize.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuestAccessAuthorize.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 login_id: _builtins.str,
                 transaction_key: _builtins.str,
                 use_sandbox: Optional[_builtins.bool] = None):
        """
        :param _builtins.str login_id: Authorize.net login ID for authentication.
        :param _builtins.str transaction_key: Authorize.net transaction key for authentication.
        :param _builtins.bool use_sandbox: Use sandbox mode for Authorize.net payments.
        """
        pulumi.set(__self__, "login_id", login_id)
        pulumi.set(__self__, "transaction_key", transaction_key)
        if use_sandbox is not None:
            pulumi.set(__self__, "use_sandbox", use_sandbox)

    @_builtins.property
    @pulumi.getter(name="loginId")
    def login_id(self) -> _builtins.str:
        """
        Authorize.net login ID for authentication.
        """
        return pulumi.get(self, "login_id")

    @_builtins.property
    @pulumi.getter(name="transactionKey")
    def transaction_key(self) -> _builtins.str:
        """
        Authorize.net transaction key for authentication.
        """
        return pulumi.get(self, "transaction_key")

    @_builtins.property
    @pulumi.getter(name="useSandbox")
    def use_sandbox(self) -> Optional[_builtins.bool]:
        """
        Use sandbox mode for Authorize.net payments.
        """
        return pulumi.get(self, "use_sandbox")


@pulumi.output_type
class GuestAccessFacebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecret":
            suggest = "app_secret"
        elif key == "scopeEmail":
            suggest = "scope_email"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuestAccessFacebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuestAccessFacebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuestAccessFacebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: _builtins.str,
                 app_secret: _builtins.str,
                 scope_email: Optional[_builtins.bool] = None):
        """
        :param _builtins.str app_id: Facebook application ID for authentication.
        :param _builtins.str app_secret: Facebook application secret for authentication.
        :param _builtins.bool scope_email: Request email scope for Facebook authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret", app_secret)
        if scope_email is not None:
            pulumi.set(__self__, "scope_email", scope_email)

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> _builtins.str:
        """
        Facebook application ID for authentication.
        """
        return pulumi.get(self, "app_id")

    @_builtins.property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> _builtins.str:
        """
        Facebook application secret for authentication.
        """
        return pulumi.get(self, "app_secret")

    @_builtins.property
    @pulumi.getter(name="scopeEmail")
    def scope_email(self) -> Optional[_builtins.bool]:
        """
        Request email scope for Facebook authentication.
        """
        return pulumi.get(self, "scope_email")


@pulumi.output_type
class GuestAccessFacebookWifi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gatewayId":
            suggest = "gateway_id"
        elif key == "gatewayName":
            suggest = "gateway_name"
        elif key == "gatewaySecret":
            suggest = "gateway_secret"
        elif key == "blockHttps":
            suggest = "block_https"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuestAccessFacebookWifi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuestAccessFacebookWifi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuestAccessFacebookWifi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gateway_id: _builtins.str,
                 gateway_name: _builtins.str,
                 gateway_secret: _builtins.str,
                 block_https: Optional[_builtins.bool] = None):
        """
        :param _builtins.str gateway_id: Facebook WiFi gateway ID.
        :param _builtins.str gateway_name: Facebook WiFi gateway name.
        :param _builtins.str gateway_secret: Facebook WiFi gateway secret.
        :param _builtins.bool block_https: Mode HTTPS for Facebook WiFi.
        """
        pulumi.set(__self__, "gateway_id", gateway_id)
        pulumi.set(__self__, "gateway_name", gateway_name)
        pulumi.set(__self__, "gateway_secret", gateway_secret)
        if block_https is not None:
            pulumi.set(__self__, "block_https", block_https)

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> _builtins.str:
        """
        Facebook WiFi gateway ID.
        """
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter(name="gatewayName")
    def gateway_name(self) -> _builtins.str:
        """
        Facebook WiFi gateway name.
        """
        return pulumi.get(self, "gateway_name")

    @_builtins.property
    @pulumi.getter(name="gatewaySecret")
    def gateway_secret(self) -> _builtins.str:
        """
        Facebook WiFi gateway secret.
        """
        return pulumi.get(self, "gateway_secret")

    @_builtins.property
    @pulumi.getter(name="blockHttps")
    def block_https(self) -> Optional[_builtins.bool]:
        """
        Mode HTTPS for Facebook WiFi.
        """
        return pulumi.get(self, "block_https")


@pulumi.output_type
class GuestAccessGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "scopeEmail":
            suggest = "scope_email"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuestAccessGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuestAccessGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuestAccessGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 client_secret: _builtins.str,
                 domain: Optional[_builtins.str] = None,
                 scope_email: Optional[_builtins.bool] = None):
        """
        :param _builtins.str client_id: Google client ID for authentication.
        :param _builtins.str client_secret: Google client secret for authentication.
        :param _builtins.str domain: Restrict Google authentication to specific domain.
        :param _builtins.bool scope_email: Request email scope for Google authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if scope_email is not None:
            pulumi.set(__self__, "scope_email", scope_email)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        Google client ID for authentication.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> _builtins.str:
        """
        Google client secret for authentication.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.str]:
        """
        Restrict Google authentication to specific domain.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="scopeEmail")
    def scope_email(self) -> Optional[_builtins.bool]:
        """
        Request email scope for Google authentication.
        """
        return pulumi.get(self, "scope_email")


@pulumi.output_type
class GuestAccessIppay(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "terminalId":
            suggest = "terminal_id"
        elif key == "useSandbox":
            suggest = "use_sandbox"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuestAccessIppay. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuestAccessIppay.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuestAccessIppay.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 terminal_id: _builtins.str,
                 use_sandbox: Optional[_builtins.bool] = None):
        """
        :param _builtins.str terminal_id: Terminal ID for IP Payments.
        :param _builtins.bool use_sandbox: Whether to use sandbox mode for IPPay payments.
        """
        pulumi.set(__self__, "terminal_id", terminal_id)
        if use_sandbox is not None:
            pulumi.set(__self__, "use_sandbox", use_sandbox)

    @_builtins.property
    @pulumi.getter(name="terminalId")
    def terminal_id(self) -> _builtins.str:
        """
        Terminal ID for IP Payments.
        """
        return pulumi.get(self, "terminal_id")

    @_builtins.property
    @pulumi.getter(name="useSandbox")
    def use_sandbox(self) -> Optional[_builtins.bool]:
        """
        Whether to use sandbox mode for IPPay payments.
        """
        return pulumi.get(self, "use_sandbox")


@pulumi.output_type
class GuestAccessMerchantWarrior(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "apiPassphrase":
            suggest = "api_passphrase"
        elif key == "merchantUuid":
            suggest = "merchant_uuid"
        elif key == "useSandbox":
            suggest = "use_sandbox"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuestAccessMerchantWarrior. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuestAccessMerchantWarrior.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuestAccessMerchantWarrior.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: _builtins.str,
                 api_passphrase: _builtins.str,
                 merchant_uuid: _builtins.str,
                 use_sandbox: Optional[_builtins.bool] = None):
        """
        :param _builtins.str api_key: MerchantWarrior API key.
        :param _builtins.str api_passphrase: MerchantWarrior API passphrase.
        :param _builtins.str merchant_uuid: MerchantWarrior merchant UUID.
        :param _builtins.bool use_sandbox: Whether to use sandbox mode for MerchantWarrior payments.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "api_passphrase", api_passphrase)
        pulumi.set(__self__, "merchant_uuid", merchant_uuid)
        if use_sandbox is not None:
            pulumi.set(__self__, "use_sandbox", use_sandbox)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        MerchantWarrior API key.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter(name="apiPassphrase")
    def api_passphrase(self) -> _builtins.str:
        """
        MerchantWarrior API passphrase.
        """
        return pulumi.get(self, "api_passphrase")

    @_builtins.property
    @pulumi.getter(name="merchantUuid")
    def merchant_uuid(self) -> _builtins.str:
        """
        MerchantWarrior merchant UUID.
        """
        return pulumi.get(self, "merchant_uuid")

    @_builtins.property
    @pulumi.getter(name="useSandbox")
    def use_sandbox(self) -> Optional[_builtins.bool]:
        """
        Whether to use sandbox mode for MerchantWarrior payments.
        """
        return pulumi.get(self, "use_sandbox")


@pulumi.output_type
class GuestAccessPaypal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useSandbox":
            suggest = "use_sandbox"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuestAccessPaypal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuestAccessPaypal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuestAccessPaypal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password: _builtins.str,
                 signature: _builtins.str,
                 username: _builtins.str,
                 use_sandbox: Optional[_builtins.bool] = None):
        """
        :param _builtins.str password: PayPal password.
        :param _builtins.str signature: PayPal signature.
        :param _builtins.str username: PayPal username. Must be a valid email address.
        :param _builtins.bool use_sandbox: Whether to use sandbox mode for PayPal payments.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "signature", signature)
        pulumi.set(__self__, "username", username)
        if use_sandbox is not None:
            pulumi.set(__self__, "use_sandbox", use_sandbox)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        PayPal password.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def signature(self) -> _builtins.str:
        """
        PayPal signature.
        """
        return pulumi.get(self, "signature")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        PayPal username. Must be a valid email address.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="useSandbox")
    def use_sandbox(self) -> Optional[_builtins.bool]:
        """
        Whether to use sandbox mode for PayPal payments.
        """
        return pulumi.get(self, "use_sandbox")


@pulumi.output_type
class GuestAccessPortalCustomization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationText":
            suggest = "authentication_text"
        elif key == "bgColor":
            suggest = "bg_color"
        elif key == "bgImageFileId":
            suggest = "bg_image_file_id"
        elif key == "bgImageTile":
            suggest = "bg_image_tile"
        elif key == "bgType":
            suggest = "bg_type"
        elif key == "boxColor":
            suggest = "box_color"
        elif key == "boxLinkColor":
            suggest = "box_link_color"
        elif key == "boxOpacity":
            suggest = "box_opacity"
        elif key == "boxRadius":
            suggest = "box_radius"
        elif key == "boxTextColor":
            suggest = "box_text_color"
        elif key == "buttonColor":
            suggest = "button_color"
        elif key == "buttonText":
            suggest = "button_text"
        elif key == "buttonTextColor":
            suggest = "button_text_color"
        elif key == "linkColor":
            suggest = "link_color"
        elif key == "logoFileId":
            suggest = "logo_file_id"
        elif key == "logoPosition":
            suggest = "logo_position"
        elif key == "logoSize":
            suggest = "logo_size"
        elif key == "successText":
            suggest = "success_text"
        elif key == "textColor":
            suggest = "text_color"
        elif key == "tosEnabled":
            suggest = "tos_enabled"
        elif key == "unsplashAuthorName":
            suggest = "unsplash_author_name"
        elif key == "unsplashAuthorUsername":
            suggest = "unsplash_author_username"
        elif key == "welcomeText":
            suggest = "welcome_text"
        elif key == "welcomeTextEnabled":
            suggest = "welcome_text_enabled"
        elif key == "welcomeTextPosition":
            suggest = "welcome_text_position"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuestAccessPortalCustomization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuestAccessPortalCustomization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuestAccessPortalCustomization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_text: Optional[_builtins.str] = None,
                 bg_color: Optional[_builtins.str] = None,
                 bg_image_file_id: Optional[_builtins.str] = None,
                 bg_image_tile: Optional[_builtins.bool] = None,
                 bg_type: Optional[_builtins.str] = None,
                 box_color: Optional[_builtins.str] = None,
                 box_link_color: Optional[_builtins.str] = None,
                 box_opacity: Optional[_builtins.int] = None,
                 box_radius: Optional[_builtins.int] = None,
                 box_text_color: Optional[_builtins.str] = None,
                 button_color: Optional[_builtins.str] = None,
                 button_text: Optional[_builtins.str] = None,
                 button_text_color: Optional[_builtins.str] = None,
                 customized: Optional[_builtins.bool] = None,
                 languages: Optional[Sequence[_builtins.str]] = None,
                 link_color: Optional[_builtins.str] = None,
                 logo_file_id: Optional[_builtins.str] = None,
                 logo_position: Optional[_builtins.str] = None,
                 logo_size: Optional[_builtins.int] = None,
                 success_text: Optional[_builtins.str] = None,
                 text_color: Optional[_builtins.str] = None,
                 title: Optional[_builtins.str] = None,
                 tos: Optional[_builtins.str] = None,
                 tos_enabled: Optional[_builtins.bool] = None,
                 unsplash_author_name: Optional[_builtins.str] = None,
                 unsplash_author_username: Optional[_builtins.str] = None,
                 welcome_text: Optional[_builtins.str] = None,
                 welcome_text_enabled: Optional[_builtins.bool] = None,
                 welcome_text_position: Optional[_builtins.str] = None):
        """
        :param _builtins.str authentication_text: Custom authentication text for the portal.
        :param _builtins.str bg_color: Background color for the custom portal. Must be a valid hex color code (e.g., #FFF or #FFFFFF).
        :param _builtins.str bg_image_file_id: ID of the background image portal file. File must exist in controller, use `port.AlFile` to manage it.
        :param _builtins.bool bg_image_tile: Tile the background image.
        :param _builtins.str bg_type: Type of portal background. Valid values are:
        :param _builtins.str box_color: Color of the login box in the portal. Must be a valid hex color code (e.g., #FFF or #FFFFFF).
        :param _builtins.str box_link_color: Color of links in the login box. Must be a valid hex color code (e.g., #FFF or #FFFFFF).
        :param _builtins.int box_opacity: Opacity of the login box (0-100).
        :param _builtins.int box_radius: Border radius of the login box in pixels.
        :param _builtins.str box_text_color: Text color in the login box. Must be a valid hex color code (e.g., #FFF or #FFFFFF).
        :param _builtins.str button_color: Button color in the portal. Must be a valid hex color code (e.g., #FFF or #FFFFFF).
        :param _builtins.str button_text: Custom text for the login button.
        :param _builtins.str button_text_color: Button text color. Must be a valid hex color code (e.g., #FFF or #FFFFFF).
        :param _builtins.bool customized: Whether the portal is customized.
        :param Sequence[_builtins.str] languages: List of enabled languages for the portal.
        :param _builtins.str link_color: Color for links in the portal. Must be a valid hex color code (e.g., #FFF or #FFFFFF).
        :param _builtins.str logo_file_id: ID of the logo image portal file. File must exist in controller, use `port.AlFile` to manage it.
        :param _builtins.str logo_position: Position of the logo in the portal. Valid values are: left, center, right.
        :param _builtins.int logo_size: Size of the logo in pixels.
        :param _builtins.str success_text: Text displayed after successful authentication.
        :param _builtins.str text_color: Main text color for the portal. Must be a valid hex color code (e.g., #FFF or #FFFFFF).
        :param _builtins.str title: Title of the portal page.
        :param _builtins.str tos: Terms of service text.
        :param _builtins.bool tos_enabled: Enable terms of service acceptance requirement.
        :param _builtins.str unsplash_author_name: Name of the Unsplash author for gallery background.
        :param _builtins.str unsplash_author_username: Username of the Unsplash author for gallery background.
        :param _builtins.str welcome_text: Welcome text displayed on the portal.
        :param _builtins.bool welcome_text_enabled: Enable welcome text display.
        :param _builtins.str welcome_text_position: Position of the welcome text. Valid values are: `under_logo`, `above_boxes`.
        """
        if authentication_text is not None:
            pulumi.set(__self__, "authentication_text", authentication_text)
        if bg_color is not None:
            pulumi.set(__self__, "bg_color", bg_color)
        if bg_image_file_id is not None:
            pulumi.set(__self__, "bg_image_file_id", bg_image_file_id)
        if bg_image_tile is not None:
            pulumi.set(__self__, "bg_image_tile", bg_image_tile)
        if bg_type is not None:
            pulumi.set(__self__, "bg_type", bg_type)
        if box_color is not None:
            pulumi.set(__self__, "box_color", box_color)
        if box_link_color is not None:
            pulumi.set(__self__, "box_link_color", box_link_color)
        if box_opacity is not None:
            pulumi.set(__self__, "box_opacity", box_opacity)
        if box_radius is not None:
            pulumi.set(__self__, "box_radius", box_radius)
        if box_text_color is not None:
            pulumi.set(__self__, "box_text_color", box_text_color)
        if button_color is not None:
            pulumi.set(__self__, "button_color", button_color)
        if button_text is not None:
            pulumi.set(__self__, "button_text", button_text)
        if button_text_color is not None:
            pulumi.set(__self__, "button_text_color", button_text_color)
        if customized is not None:
            pulumi.set(__self__, "customized", customized)
        if languages is not None:
            pulumi.set(__self__, "languages", languages)
        if link_color is not None:
            pulumi.set(__self__, "link_color", link_color)
        if logo_file_id is not None:
            pulumi.set(__self__, "logo_file_id", logo_file_id)
        if logo_position is not None:
            pulumi.set(__self__, "logo_position", logo_position)
        if logo_size is not None:
            pulumi.set(__self__, "logo_size", logo_size)
        if success_text is not None:
            pulumi.set(__self__, "success_text", success_text)
        if text_color is not None:
            pulumi.set(__self__, "text_color", text_color)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if tos is not None:
            pulumi.set(__self__, "tos", tos)
        if tos_enabled is not None:
            pulumi.set(__self__, "tos_enabled", tos_enabled)
        if unsplash_author_name is not None:
            pulumi.set(__self__, "unsplash_author_name", unsplash_author_name)
        if unsplash_author_username is not None:
            pulumi.set(__self__, "unsplash_author_username", unsplash_author_username)
        if welcome_text is not None:
            pulumi.set(__self__, "welcome_text", welcome_text)
        if welcome_text_enabled is not None:
            pulumi.set(__self__, "welcome_text_enabled", welcome_text_enabled)
        if welcome_text_position is not None:
            pulumi.set(__self__, "welcome_text_position", welcome_text_position)

    @_builtins.property
    @pulumi.getter(name="authenticationText")
    def authentication_text(self) -> Optional[_builtins.str]:
        """
        Custom authentication text for the portal.
        """
        return pulumi.get(self, "authentication_text")

    @_builtins.property
    @pulumi.getter(name="bgColor")
    def bg_color(self) -> Optional[_builtins.str]:
        """
        Background color for the custom portal. Must be a valid hex color code (e.g., #FFF or #FFFFFF).
        """
        return pulumi.get(self, "bg_color")

    @_builtins.property
    @pulumi.getter(name="bgImageFileId")
    def bg_image_file_id(self) -> Optional[_builtins.str]:
        """
        ID of the background image portal file. File must exist in controller, use `port.AlFile` to manage it.
        """
        return pulumi.get(self, "bg_image_file_id")

    @_builtins.property
    @pulumi.getter(name="bgImageTile")
    def bg_image_tile(self) -> Optional[_builtins.bool]:
        """
        Tile the background image.
        """
        return pulumi.get(self, "bg_image_tile")

    @_builtins.property
    @pulumi.getter(name="bgType")
    def bg_type(self) -> Optional[_builtins.str]:
        """
        Type of portal background. Valid values are:
        """
        return pulumi.get(self, "bg_type")

    @_builtins.property
    @pulumi.getter(name="boxColor")
    def box_color(self) -> Optional[_builtins.str]:
        """
        Color of the login box in the portal. Must be a valid hex color code (e.g., #FFF or #FFFFFF).
        """
        return pulumi.get(self, "box_color")

    @_builtins.property
    @pulumi.getter(name="boxLinkColor")
    def box_link_color(self) -> Optional[_builtins.str]:
        """
        Color of links in the login box. Must be a valid hex color code (e.g., #FFF or #FFFFFF).
        """
        return pulumi.get(self, "box_link_color")

    @_builtins.property
    @pulumi.getter(name="boxOpacity")
    def box_opacity(self) -> Optional[_builtins.int]:
        """
        Opacity of the login box (0-100).
        """
        return pulumi.get(self, "box_opacity")

    @_builtins.property
    @pulumi.getter(name="boxRadius")
    def box_radius(self) -> Optional[_builtins.int]:
        """
        Border radius of the login box in pixels.
        """
        return pulumi.get(self, "box_radius")

    @_builtins.property
    @pulumi.getter(name="boxTextColor")
    def box_text_color(self) -> Optional[_builtins.str]:
        """
        Text color in the login box. Must be a valid hex color code (e.g., #FFF or #FFFFFF).
        """
        return pulumi.get(self, "box_text_color")

    @_builtins.property
    @pulumi.getter(name="buttonColor")
    def button_color(self) -> Optional[_builtins.str]:
        """
        Button color in the portal. Must be a valid hex color code (e.g., #FFF or #FFFFFF).
        """
        return pulumi.get(self, "button_color")

    @_builtins.property
    @pulumi.getter(name="buttonText")
    def button_text(self) -> Optional[_builtins.str]:
        """
        Custom text for the login button.
        """
        return pulumi.get(self, "button_text")

    @_builtins.property
    @pulumi.getter(name="buttonTextColor")
    def button_text_color(self) -> Optional[_builtins.str]:
        """
        Button text color. Must be a valid hex color code (e.g., #FFF or #FFFFFF).
        """
        return pulumi.get(self, "button_text_color")

    @_builtins.property
    @pulumi.getter
    def customized(self) -> Optional[_builtins.bool]:
        """
        Whether the portal is customized.
        """
        return pulumi.get(self, "customized")

    @_builtins.property
    @pulumi.getter
    def languages(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of enabled languages for the portal.
        """
        return pulumi.get(self, "languages")

    @_builtins.property
    @pulumi.getter(name="linkColor")
    def link_color(self) -> Optional[_builtins.str]:
        """
        Color for links in the portal. Must be a valid hex color code (e.g., #FFF or #FFFFFF).
        """
        return pulumi.get(self, "link_color")

    @_builtins.property
    @pulumi.getter(name="logoFileId")
    def logo_file_id(self) -> Optional[_builtins.str]:
        """
        ID of the logo image portal file. File must exist in controller, use `port.AlFile` to manage it.
        """
        return pulumi.get(self, "logo_file_id")

    @_builtins.property
    @pulumi.getter(name="logoPosition")
    def logo_position(self) -> Optional[_builtins.str]:
        """
        Position of the logo in the portal. Valid values are: left, center, right.
        """
        return pulumi.get(self, "logo_position")

    @_builtins.property
    @pulumi.getter(name="logoSize")
    def logo_size(self) -> Optional[_builtins.int]:
        """
        Size of the logo in pixels.
        """
        return pulumi.get(self, "logo_size")

    @_builtins.property
    @pulumi.getter(name="successText")
    def success_text(self) -> Optional[_builtins.str]:
        """
        Text displayed after successful authentication.
        """
        return pulumi.get(self, "success_text")

    @_builtins.property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional[_builtins.str]:
        """
        Main text color for the portal. Must be a valid hex color code (e.g., #FFF or #FFFFFF).
        """
        return pulumi.get(self, "text_color")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        Title of the portal page.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def tos(self) -> Optional[_builtins.str]:
        """
        Terms of service text.
        """
        return pulumi.get(self, "tos")

    @_builtins.property
    @pulumi.getter(name="tosEnabled")
    def tos_enabled(self) -> Optional[_builtins.bool]:
        """
        Enable terms of service acceptance requirement.
        """
        return pulumi.get(self, "tos_enabled")

    @_builtins.property
    @pulumi.getter(name="unsplashAuthorName")
    def unsplash_author_name(self) -> Optional[_builtins.str]:
        """
        Name of the Unsplash author for gallery background.
        """
        return pulumi.get(self, "unsplash_author_name")

    @_builtins.property
    @pulumi.getter(name="unsplashAuthorUsername")
    def unsplash_author_username(self) -> Optional[_builtins.str]:
        """
        Username of the Unsplash author for gallery background.
        """
        return pulumi.get(self, "unsplash_author_username")

    @_builtins.property
    @pulumi.getter(name="welcomeText")
    def welcome_text(self) -> Optional[_builtins.str]:
        """
        Welcome text displayed on the portal.
        """
        return pulumi.get(self, "welcome_text")

    @_builtins.property
    @pulumi.getter(name="welcomeTextEnabled")
    def welcome_text_enabled(self) -> Optional[_builtins.bool]:
        """
        Enable welcome text display.
        """
        return pulumi.get(self, "welcome_text_enabled")

    @_builtins.property
    @pulumi.getter(name="welcomeTextPosition")
    def welcome_text_position(self) -> Optional[_builtins.str]:
        """
        Position of the welcome text. Valid values are: `under_logo`, `above_boxes`.
        """
        return pulumi.get(self, "welcome_text_position")


@pulumi.output_type
class GuestAccessQuickpay(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agreementId":
            suggest = "agreement_id"
        elif key == "apiKey":
            suggest = "api_key"
        elif key == "merchantId":
            suggest = "merchant_id"
        elif key == "useSandbox":
            suggest = "use_sandbox"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuestAccessQuickpay. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuestAccessQuickpay.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuestAccessQuickpay.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agreement_id: _builtins.str,
                 api_key: _builtins.str,
                 merchant_id: _builtins.str,
                 use_sandbox: Optional[_builtins.bool] = None):
        """
        :param _builtins.str agreement_id: QuickPay agreement ID.
        :param _builtins.str api_key: QuickPay API key.
        :param _builtins.str merchant_id: QuickPay merchant ID.
        :param _builtins.bool use_sandbox: Enable sandbox mode for QuickPay payments.
        """
        pulumi.set(__self__, "agreement_id", agreement_id)
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "merchant_id", merchant_id)
        if use_sandbox is not None:
            pulumi.set(__self__, "use_sandbox", use_sandbox)

    @_builtins.property
    @pulumi.getter(name="agreementId")
    def agreement_id(self) -> _builtins.str:
        """
        QuickPay agreement ID.
        """
        return pulumi.get(self, "agreement_id")

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        QuickPay API key.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter(name="merchantId")
    def merchant_id(self) -> _builtins.str:
        """
        QuickPay merchant ID.
        """
        return pulumi.get(self, "merchant_id")

    @_builtins.property
    @pulumi.getter(name="useSandbox")
    def use_sandbox(self) -> Optional[_builtins.bool]:
        """
        Enable sandbox mode for QuickPay payments.
        """
        return pulumi.get(self, "use_sandbox")


@pulumi.output_type
class GuestAccessRadius(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "profileId":
            suggest = "profile_id"
        elif key == "disconnectEnabled":
            suggest = "disconnect_enabled"
        elif key == "disconnectPort":
            suggest = "disconnect_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuestAccessRadius. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuestAccessRadius.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuestAccessRadius.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: _builtins.str,
                 profile_id: _builtins.str,
                 disconnect_enabled: Optional[_builtins.bool] = None,
                 disconnect_port: Optional[_builtins.int] = None):
        """
        :param _builtins.str auth_type: RADIUS authentication type. Valid values are: `chap`, `mschapv2`.
        :param _builtins.str profile_id: ID of the RADIUS profile to use.
        :param _builtins.bool disconnect_enabled: Enable RADIUS disconnect messages.
        :param _builtins.int disconnect_port: Port for RADIUS disconnect messages.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "profile_id", profile_id)
        if disconnect_enabled is not None:
            pulumi.set(__self__, "disconnect_enabled", disconnect_enabled)
        if disconnect_port is not None:
            pulumi.set(__self__, "disconnect_port", disconnect_port)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> _builtins.str:
        """
        RADIUS authentication type. Valid values are: `chap`, `mschapv2`.
        """
        return pulumi.get(self, "auth_type")

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> _builtins.str:
        """
        ID of the RADIUS profile to use.
        """
        return pulumi.get(self, "profile_id")

    @_builtins.property
    @pulumi.getter(name="disconnectEnabled")
    def disconnect_enabled(self) -> Optional[_builtins.bool]:
        """
        Enable RADIUS disconnect messages.
        """
        return pulumi.get(self, "disconnect_enabled")

    @_builtins.property
    @pulumi.getter(name="disconnectPort")
    def disconnect_port(self) -> Optional[_builtins.int]:
        """
        Port for RADIUS disconnect messages.
        """
        return pulumi.get(self, "disconnect_port")


@pulumi.output_type
class GuestAccessRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toHttps":
            suggest = "to_https"
        elif key == "useHttps":
            suggest = "use_https"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuestAccessRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuestAccessRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuestAccessRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 to_https: Optional[_builtins.bool] = None,
                 use_https: Optional[_builtins.bool] = None):
        """
        :param _builtins.str url: URL to redirect to after authentication. Must be a valid URL.
        :param _builtins.bool to_https: Redirect HTTP requests to HTTPS.
        :param _builtins.bool use_https: Use HTTPS for the redirect URL.
        """
        pulumi.set(__self__, "url", url)
        if to_https is not None:
            pulumi.set(__self__, "to_https", to_https)
        if use_https is not None:
            pulumi.set(__self__, "use_https", use_https)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        URL to redirect to after authentication. Must be a valid URL.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="toHttps")
    def to_https(self) -> Optional[_builtins.bool]:
        """
        Redirect HTTP requests to HTTPS.
        """
        return pulumi.get(self, "to_https")

    @_builtins.property
    @pulumi.getter(name="useHttps")
    def use_https(self) -> Optional[_builtins.bool]:
        """
        Use HTTPS for the redirect URL.
        """
        return pulumi.get(self, "use_https")


@pulumi.output_type
class GuestAccessStripe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuestAccessStripe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuestAccessStripe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuestAccessStripe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: _builtins.str):
        """
        :param _builtins.str api_key: Stripe API key.
        """
        pulumi.set(__self__, "api_key", api_key)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        Stripe API key.
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class GuestAccessWechat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecret":
            suggest = "app_secret"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "shopId":
            suggest = "shop_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuestAccessWechat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuestAccessWechat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuestAccessWechat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: _builtins.str,
                 app_secret: _builtins.str,
                 secret_key: _builtins.str,
                 shop_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str app_id: WeChat App ID for social authentication.
        :param _builtins.str app_secret: WeChat App secret.
        :param _builtins.str secret_key: WeChat secret key.
        :param _builtins.str shop_id: WeChat Shop ID for payments.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret", app_secret)
        pulumi.set(__self__, "secret_key", secret_key)
        if shop_id is not None:
            pulumi.set(__self__, "shop_id", shop_id)

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> _builtins.str:
        """
        WeChat App ID for social authentication.
        """
        return pulumi.get(self, "app_id")

    @_builtins.property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> _builtins.str:
        """
        WeChat App secret.
        """
        return pulumi.get(self, "app_secret")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> _builtins.str:
        """
        WeChat secret key.
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter(name="shopId")
    def shop_id(self) -> Optional[_builtins.str]:
        """
        WeChat Shop ID for payments.
        """
        return pulumi.get(self, "shop_id")


@pulumi.output_type
class IpsDnsFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkId":
            suggest = "network_id"
        elif key == "allowedSites":
            suggest = "allowed_sites"
        elif key == "blockedSites":
            suggest = "blocked_sites"
        elif key == "blockedTlds":
            suggest = "blocked_tlds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpsDnsFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpsDnsFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpsDnsFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter: _builtins.str,
                 name: _builtins.str,
                 network_id: _builtins.str,
                 allowed_sites: Optional[Sequence[_builtins.str]] = None,
                 blocked_sites: Optional[Sequence[_builtins.str]] = None,
                 blocked_tlds: Optional[Sequence[_builtins.str]] = None,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str filter: Filter type that determines the predefined filtering level. Valid values are:
                 * `none` - No predefined filtering
                 * `work` - Work-appropriate filtering that blocks adult content
                 * `family` - Family-friendly filtering that blocks adult content and other inappropriate sites
        :param _builtins.str name: Name of the DNS filter. This is used to identify the filter in the UniFi interface.
        :param _builtins.str network_id: Network ID this filter applies to. This should be a valid network ID from your UniFi configuration.
        :param Sequence[_builtins.str] allowed_sites: List of allowed sites for this DNS filter. These domains will always be accessible regardless of other filtering rules. Each entry should be a valid domain name (e.g., `example.com`).
        :param Sequence[_builtins.str] blocked_sites: List of blocked sites for this DNS filter. These domains will be blocked regardless of other filtering rules. Each entry should be a valid domain name (e.g., `example.com`).
        :param Sequence[_builtins.str] blocked_tlds: List of blocked top-level domains (TLDs) for this DNS filter. All domains with these TLDs will be blocked. Each entry should be a valid TLD without the dot prefix (e.g., `xyz`, `info`).
        :param _builtins.str description: Description of the DNS filter. This is used for documentation purposes only and does not affect functionality.
        """
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_id", network_id)
        if allowed_sites is not None:
            pulumi.set(__self__, "allowed_sites", allowed_sites)
        if blocked_sites is not None:
            pulumi.set(__self__, "blocked_sites", blocked_sites)
        if blocked_tlds is not None:
            pulumi.set(__self__, "blocked_tlds", blocked_tlds)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> _builtins.str:
        """
        Filter type that determines the predefined filtering level. Valid values are:
          * `none` - No predefined filtering
          * `work` - Work-appropriate filtering that blocks adult content
          * `family` - Family-friendly filtering that blocks adult content and other inappropriate sites
        """
        return pulumi.get(self, "filter")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the DNS filter. This is used to identify the filter in the UniFi interface.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> _builtins.str:
        """
        Network ID this filter applies to. This should be a valid network ID from your UniFi configuration.
        """
        return pulumi.get(self, "network_id")

    @_builtins.property
    @pulumi.getter(name="allowedSites")
    def allowed_sites(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of allowed sites for this DNS filter. These domains will always be accessible regardless of other filtering rules. Each entry should be a valid domain name (e.g., `example.com`).
        """
        return pulumi.get(self, "allowed_sites")

    @_builtins.property
    @pulumi.getter(name="blockedSites")
    def blocked_sites(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of blocked sites for this DNS filter. These domains will be blocked regardless of other filtering rules. Each entry should be a valid domain name (e.g., `example.com`).
        """
        return pulumi.get(self, "blocked_sites")

    @_builtins.property
    @pulumi.getter(name="blockedTlds")
    def blocked_tlds(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of blocked top-level domains (TLDs) for this DNS filter. All domains with these TLDs will be blocked. Each entry should be a valid TLD without the dot prefix (e.g., `xyz`, `info`).
        """
        return pulumi.get(self, "blocked_tlds")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the DNS filter. This is used for documentation purposes only and does not affect functionality.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class IpsHoneypot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "networkId":
            suggest = "network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpsHoneypot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpsHoneypot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpsHoneypot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: _builtins.str,
                 network_id: _builtins.str):
        """
        :param _builtins.str ip_address: IP address for the honeypot. This should be an unused IPv4 address within your network range that will be used as a decoy system.
        :param _builtins.str network_id: Network ID for the honeypot. This should be a valid network ID from your UniFi configuration where the honeypot will be deployed.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "network_id", network_id)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> _builtins.str:
        """
        IP address for the honeypot. This should be an unused IPv4 address within your network range that will be used as a decoy system.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> _builtins.str:
        """
        Network ID for the honeypot. This should be a valid network ID from your UniFi configuration where the honeypot will be deployed.
        """
        return pulumi.get(self, "network_id")


@pulumi.output_type
class IpsSuppression(dict):
    def __init__(__self__, *,
                 alerts: Optional[Sequence['outputs.IpsSuppressionAlert']] = None,
                 whitelists: Optional[Sequence['outputs.IpsSuppressionWhitelist']] = None):
        """
        :param Sequence['IpsSuppressionAlertArgs'] alerts: Alert suppressions. Each entry defines a specific IPS alert that should be suppressed or tracked differently from the default behavior.
        :param Sequence['IpsSuppressionWhitelistArgs'] whitelists: Whitelist configuration. Each entry defines traffic that should never trigger IPS alerts, regardless of other rules.
        """
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if whitelists is not None:
            pulumi.set(__self__, "whitelists", whitelists)

    @_builtins.property
    @pulumi.getter
    def alerts(self) -> Optional[Sequence['outputs.IpsSuppressionAlert']]:
        """
        Alert suppressions. Each entry defines a specific IPS alert that should be suppressed or tracked differently from the default behavior.
        """
        return pulumi.get(self, "alerts")

    @_builtins.property
    @pulumi.getter
    def whitelists(self) -> Optional[Sequence['outputs.IpsSuppressionWhitelist']]:
        """
        Whitelist configuration. Each entry defines traffic that should never trigger IPS alerts, regardless of other rules.
        """
        return pulumi.get(self, "whitelists")


@pulumi.output_type
class IpsSuppressionAlert(dict):
    def __init__(__self__, *,
                 category: _builtins.str,
                 signature: _builtins.str,
                 type: _builtins.str,
                 trackings: Optional[Sequence['outputs.IpsSuppressionAlertTracking']] = None):
        """
        :param _builtins.str category: Category of the alert to suppress. This should match one of the categories from the enabled_categories list.
        :param _builtins.str signature: Signature name of the alert to suppress. This is a human-readable identifier for the alert in the IPS ruleset.
        :param _builtins.str type: Type of suppression. Valid values are:
                 * `all` - Suppress all occurrences of this alert
                 * `track` - Only track this alert according to the tracking configuration
        :param Sequence['IpsSuppressionAlertTrackingArgs'] trackings: Tracking configuration for the alert. This defines how the system should track occurrences of this alert based on source/destination addresses.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "signature", signature)
        pulumi.set(__self__, "type", type)
        if trackings is not None:
            pulumi.set(__self__, "trackings", trackings)

    @_builtins.property
    @pulumi.getter
    def category(self) -> _builtins.str:
        """
        Category of the alert to suppress. This should match one of the categories from the enabled_categories list.
        """
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter
    def signature(self) -> _builtins.str:
        """
        Signature name of the alert to suppress. This is a human-readable identifier for the alert in the IPS ruleset.
        """
        return pulumi.get(self, "signature")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of suppression. Valid values are:
          * `all` - Suppress all occurrences of this alert
          * `track` - Only track this alert according to the tracking configuration
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def trackings(self) -> Optional[Sequence['outputs.IpsSuppressionAlertTracking']]:
        """
        Tracking configuration for the alert. This defines how the system should track occurrences of this alert based on source/destination addresses.
        """
        return pulumi.get(self, "trackings")


@pulumi.output_type
class IpsSuppressionAlertTracking(dict):
    def __init__(__self__, *,
                 direction: _builtins.str,
                 mode: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str direction: Direction for tracking. Valid values are:
                 * `src` - Track by source address
                 * `dest` - Track by destination address
                 * `both` - Track by both source and destination addresses
        :param _builtins.str mode: Mode for tracking. Valid values are:
                 * `ip` - Track by individual IP address
                 * `subnet` - Track by subnet
                 * `network` - Track by network ID
        :param _builtins.str value: Value for tracking. The meaning depends on the mode:
                 * For `ip` mode: An IP address (e.g., `192.168.1.100`)
                 * For `subnet` mode: A CIDR notation subnet (e.g., `192.168.1.0/24`)
                 * For `network` mode: A network ID from your UniFi configuration
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> _builtins.str:
        """
        Direction for tracking. Valid values are:
          * `src` - Track by source address
          * `dest` - Track by destination address
          * `both` - Track by both source and destination addresses
        """
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Mode for tracking. Valid values are:
          * `ip` - Track by individual IP address
          * `subnet` - Track by subnet
          * `network` - Track by network ID
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value for tracking. The meaning depends on the mode:
          * For `ip` mode: An IP address (e.g., `192.168.1.100`)
          * For `subnet` mode: A CIDR notation subnet (e.g., `192.168.1.0/24`)
          * For `network` mode: A network ID from your UniFi configuration
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IpsSuppressionWhitelist(dict):
    def __init__(__self__, *,
                 direction: _builtins.str,
                 mode: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str direction: Direction for whitelist. Valid values are:
                 * `src` - Whitelist by source address
                 * `dst` - Whitelist by destination address
                 * `both` - Whitelist by both source and destination addresses
        :param _builtins.str mode: Mode for whitelist. Valid values are:
                 * `ip` - Whitelist by individual IP address
                 * `subnet` - Whitelist by subnet
                 * `network` - Whitelist by network ID
        :param _builtins.str value: Value for whitelist. The meaning depends on the mode:
                 * For `ip` mode: An IP address (e.g., `192.168.1.100`)
                 * For `subnet` mode: A CIDR notation subnet (e.g., `192.168.1.0/24`)
                 * For `network` mode: A network ID from your UniFi configuration
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> _builtins.str:
        """
        Direction for whitelist. Valid values are:
          * `src` - Whitelist by source address
          * `dst` - Whitelist by destination address
          * `both` - Whitelist by both source and destination addresses
        """
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Mode for whitelist. Valid values are:
          * `ip` - Whitelist by individual IP address
          * `subnet` - Whitelist by subnet
          * `network` - Whitelist by network ID
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value for whitelist. The meaning depends on the mode:
          * For `ip` mode: An IP address (e.g., `192.168.1.100`)
          * For `subnet` mode: A CIDR notation subnet (e.g., `192.168.1.0/24`)
          * For `network` mode: A network ID from your UniFi configuration
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class MgmtSshKey(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str,
                 comment: Optional[_builtins.str] = None,
                 key: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: A friendly name for the SSH key to help identify its owner or purpose (e.g., 'admin-laptop' or 'backup-server').
        :param _builtins.str type: The type of SSH key. Common values include:
                 * `ssh-rsa` - RSA key (most common)
                 * `ssh-ed25519` - Ed25519 key (more secure)
                 * `ecdsa-sha2-nistp256` - ECDSA key
        :param _builtins.str comment: An optional comment to provide additional context about the key (e.g., 'generated on 2024-01-01' or 'expires 2025-12-31').
        :param _builtins.str key: The public key string. This is the content that would normally go in an authorized_keys file, excluding the type and comment (e.g., 'AAAAB3NzaC1yc2EA...').
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A friendly name for the SSH key to help identify its owner or purpose (e.g., 'admin-laptop' or 'backup-server').
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of SSH key. Common values include:
          * `ssh-rsa` - RSA key (most common)
          * `ssh-ed25519` - Ed25519 key (more secure)
          * `ecdsa-sha2-nistp256` - ECDSA key
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        An optional comment to provide additional context about the key (e.g., 'generated on 2024-01-01' or 'expires 2025-12-31').
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The public key string. This is the content that would normally go in an authorized_keys file, excluding the type and comment (e.g., 'AAAAB3NzaC1yc2EA...').
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class USGDhcpRelay(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentsPackets":
            suggest = "agents_packets"
        elif key == "hopCount":
            suggest = "hop_count"
        elif key == "maxSize":
            suggest = "max_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in USGDhcpRelay. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        USGDhcpRelay.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        USGDhcpRelay.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agents_packets: Optional[_builtins.str] = None,
                 hop_count: Optional[_builtins.int] = None,
                 max_size: Optional[_builtins.int] = None,
                 port: Optional[_builtins.int] = None):
        """
        :param _builtins.str agents_packets: Specifies how to handle DHCP relay agent information in packets. Valid values are:
                 * `append` - Add relay agent information to packets that may already contain it
                 * `discard` - Drop packets that already contain relay agent information
                 * `forward` - Forward packets regardless of relay agent information
                 * `replace` - Replace existing relay agent information with the gateway's information
        :param _builtins.int hop_count: Maximum number of relay agents that can forward the DHCP packet before it is discarded. This prevents DHCP packets from being forwarded indefinitely in complex network topologies. Valid values range from 1 to 255, with lower values recommended for simpler networks.
        :param _builtins.int max_size: Maximum size (in bytes) of DHCP relay packets that will be forwarded. Packets exceeding this size will be truncated or dropped. Valid values range from 64 to 1400 bytes. The default is typically sufficient for most DHCP implementations, but may need adjustment if using extensive DHCP options or vendor-specific information.
        :param _builtins.int port: UDP port number for the DHCP relay service to listen on. The standard DHCP server port is 67, but this can be customized if needed for specific network configurations. Valid values range from 1 to 65535. Ensure this doesn't conflict with other services running on the gateway.
        """
        if agents_packets is not None:
            pulumi.set(__self__, "agents_packets", agents_packets)
        if hop_count is not None:
            pulumi.set(__self__, "hop_count", hop_count)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter(name="agentsPackets")
    def agents_packets(self) -> Optional[_builtins.str]:
        """
        Specifies how to handle DHCP relay agent information in packets. Valid values are:
          * `append` - Add relay agent information to packets that may already contain it
          * `discard` - Drop packets that already contain relay agent information
          * `forward` - Forward packets regardless of relay agent information
          * `replace` - Replace existing relay agent information with the gateway's information
        """
        return pulumi.get(self, "agents_packets")

    @_builtins.property
    @pulumi.getter(name="hopCount")
    def hop_count(self) -> Optional[_builtins.int]:
        """
        Maximum number of relay agents that can forward the DHCP packet before it is discarded. This prevents DHCP packets from being forwarded indefinitely in complex network topologies. Valid values range from 1 to 255, with lower values recommended for simpler networks.
        """
        return pulumi.get(self, "hop_count")

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[_builtins.int]:
        """
        Maximum size (in bytes) of DHCP relay packets that will be forwarded. Packets exceeding this size will be truncated or dropped. Valid values range from 64 to 1400 bytes. The default is typically sufficient for most DHCP implementations, but may need adjustment if using extensive DHCP options or vendor-specific information.
        """
        return pulumi.get(self, "max_size")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        UDP port number for the DHCP relay service to listen on. The standard DHCP server port is 67, but this can be customized if needed for specific network configurations. Valid values range from 1 to 65535. Ensure this doesn't conflict with other services running on the gateway.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class USGDnsVerification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryDnsServer":
            suggest = "primary_dns_server"
        elif key == "secondaryDnsServer":
            suggest = "secondary_dns_server"
        elif key == "settingPreference":
            suggest = "setting_preference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in USGDnsVerification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        USGDnsVerification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        USGDnsVerification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: Optional[_builtins.str] = None,
                 primary_dns_server: Optional[_builtins.str] = None,
                 secondary_dns_server: Optional[_builtins.str] = None,
                 setting_preference: Optional[_builtins.str] = None):
        """
        :param _builtins.str domain: The domain name to use for DNS verification tests. The gateway will query this domain when testing DNS server responses. This should be a reliable domain that is unlikely to change frequently. Required when `setting_preference` is set to `manual`.
        :param _builtins.str primary_dns_server: The IP address of the primary trusted DNS server to use for verification. DNS responses will be compared against responses from this server to detect potential DNS spoofing. Required when `setting_preference` is set to `manual`. Must be a valid IPv4 address.
        :param _builtins.str secondary_dns_server: The IP address of the secondary trusted DNS server to use for verification. This server will be used if the primary server is unavailable. Optional even when `setting_preference` is set to `manual`. Must be a valid IPv4 address if specified.
        :param _builtins.str setting_preference: Determines how DNS verification servers are configured. Valid values are:
                 * `auto` - The gateway will automatically select DNS servers for verification
                 * `manual` - Use the manually specified `primary_dns_server` and optionally `secondary_dns_server`
               
               When set to `manual`, you must also specify `primary_dns_server` and `domain` values.
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if primary_dns_server is not None:
            pulumi.set(__self__, "primary_dns_server", primary_dns_server)
        if secondary_dns_server is not None:
            pulumi.set(__self__, "secondary_dns_server", secondary_dns_server)
        if setting_preference is not None:
            pulumi.set(__self__, "setting_preference", setting_preference)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.str]:
        """
        The domain name to use for DNS verification tests. The gateway will query this domain when testing DNS server responses. This should be a reliable domain that is unlikely to change frequently. Required when `setting_preference` is set to `manual`.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="primaryDnsServer")
    def primary_dns_server(self) -> Optional[_builtins.str]:
        """
        The IP address of the primary trusted DNS server to use for verification. DNS responses will be compared against responses from this server to detect potential DNS spoofing. Required when `setting_preference` is set to `manual`. Must be a valid IPv4 address.
        """
        return pulumi.get(self, "primary_dns_server")

    @_builtins.property
    @pulumi.getter(name="secondaryDnsServer")
    def secondary_dns_server(self) -> Optional[_builtins.str]:
        """
        The IP address of the secondary trusted DNS server to use for verification. This server will be used if the primary server is unavailable. Optional even when `setting_preference` is set to `manual`. Must be a valid IPv4 address if specified.
        """
        return pulumi.get(self, "secondary_dns_server")

    @_builtins.property
    @pulumi.getter(name="settingPreference")
    def setting_preference(self) -> Optional[_builtins.str]:
        """
        Determines how DNS verification servers are configured. Valid values are:
          * `auto` - The gateway will automatically select DNS servers for verification
          * `manual` - Use the manually specified `primary_dns_server` and optionally `secondary_dns_server`

        When set to `manual`, you must also specify `primary_dns_server` and `domain` values.
        """
        return pulumi.get(self, "setting_preference")


@pulumi.output_type
class USGGeoIpFiltering(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trafficDirection":
            suggest = "traffic_direction"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in USGGeoIpFiltering. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        USGGeoIpFiltering.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        USGGeoIpFiltering.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 countries: Sequence[_builtins.str],
                 mode: Optional[_builtins.str] = None,
                 traffic_direction: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] countries: List of two-letter ISO 3166-1 alpha-2 country codes to block or allow, depending on the `block` setting. Must contain at least one country code when geo IP filtering is enabled. Country codes are case-insensitive but are typically written in uppercase.
               
               Examples:
                 * `['US', 'CA', 'MX']` - United States, Canada, and Mexico
                 * `['CN', 'RU', 'IR']` - China, Russia, and Iran
                 * `['GB', 'DE', 'FR']` - United Kingdom, Germany, and France
        :param _builtins.str mode: Specifies whether the selected countries should be blocked or allowed. Valid values are:
                 * `block` (default) - Traffic from the specified countries will be blocked, while traffic from all other countries will be allowed
                 * `allow` - Only traffic from the specified countries will be allowed, while traffic from all other countries will be blocked
               
               This setting effectively determines whether the `countries` list functions as a blocklist or an allowlist.
        :param _builtins.str traffic_direction: Specifies which traffic direction the geo IP filtering applies to. Valid values are:
                 * `both` (default) - Filters traffic in both directions (incoming and outgoing)
                 * `ingress` - Filters only incoming traffic (from WAN to LAN)
                 * `egress` - Filters only outgoing traffic (from LAN to WAN)
               
               This setting is useful for creating more granular filtering policies. For example, you might want to block incoming traffic from certain countries while still allowing outgoing connections to those same countries.
        """
        pulumi.set(__self__, "countries", countries)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if traffic_direction is not None:
            pulumi.set(__self__, "traffic_direction", traffic_direction)

    @_builtins.property
    @pulumi.getter
    def countries(self) -> Sequence[_builtins.str]:
        """
        List of two-letter ISO 3166-1 alpha-2 country codes to block or allow, depending on the `block` setting. Must contain at least one country code when geo IP filtering is enabled. Country codes are case-insensitive but are typically written in uppercase.

        Examples:
          * `['US', 'CA', 'MX']` - United States, Canada, and Mexico
          * `['CN', 'RU', 'IR']` - China, Russia, and Iran
          * `['GB', 'DE', 'FR']` - United Kingdom, Germany, and France
        """
        return pulumi.get(self, "countries")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Specifies whether the selected countries should be blocked or allowed. Valid values are:
          * `block` (default) - Traffic from the specified countries will be blocked, while traffic from all other countries will be allowed
          * `allow` - Only traffic from the specified countries will be allowed, while traffic from all other countries will be blocked

        This setting effectively determines whether the `countries` list functions as a blocklist or an allowlist.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="trafficDirection")
    def traffic_direction(self) -> Optional[_builtins.str]:
        """
        Specifies which traffic direction the geo IP filtering applies to. Valid values are:
          * `both` (default) - Filters traffic in both directions (incoming and outgoing)
          * `ingress` - Filters only incoming traffic (from WAN to LAN)
          * `egress` - Filters only outgoing traffic (from LAN to WAN)

        This setting is useful for creating more granular filtering policies. For example, you might want to block incoming traffic from certain countries while still allowing outgoing connections to those same countries.
        """
        return pulumi.get(self, "traffic_direction")


@pulumi.output_type
class USGTcpTimeouts(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "closeTimeout":
            suggest = "close_timeout"
        elif key == "closeWaitTimeout":
            suggest = "close_wait_timeout"
        elif key == "establishedTimeout":
            suggest = "established_timeout"
        elif key == "finWaitTimeout":
            suggest = "fin_wait_timeout"
        elif key == "lastAckTimeout":
            suggest = "last_ack_timeout"
        elif key == "synRecvTimeout":
            suggest = "syn_recv_timeout"
        elif key == "synSentTimeout":
            suggest = "syn_sent_timeout"
        elif key == "timeWaitTimeout":
            suggest = "time_wait_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in USGTcpTimeouts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        USGTcpTimeouts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        USGTcpTimeouts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 close_timeout: Optional[_builtins.int] = None,
                 close_wait_timeout: Optional[_builtins.int] = None,
                 established_timeout: Optional[_builtins.int] = None,
                 fin_wait_timeout: Optional[_builtins.int] = None,
                 last_ack_timeout: Optional[_builtins.int] = None,
                 syn_recv_timeout: Optional[_builtins.int] = None,
                 syn_sent_timeout: Optional[_builtins.int] = None,
                 time_wait_timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.int close_timeout: Timeout (in seconds) for TCP connections in the CLOSE state. The CLOSE state occurs when a connection is being terminated but may still have packets in transit. Lower values reclaim resources more quickly, while higher values ensure all packets are properly processed during connection termination.
        :param _builtins.int close_wait_timeout: Timeout (in seconds) for TCP connections in the CLOSE_WAIT state. The CLOSE_WAIT state occurs when the remote end has initiated connection termination, but the local application hasn't closed the connection yet. This timeout prevents resources from being held indefinitely if a local application fails to properly close its connection.
        :param _builtins.int established_timeout: Timeout (in seconds) for TCP connections in the ESTABLISHED state. This is the most important TCP timeout as it determines how long idle but established connections are maintained in the connection tracking table. Higher values (e.g., 86400 = 24 hours) are suitable for long-lived connections, while lower values conserve resources but may cause issues with applications that maintain idle connections.
        :param _builtins.int fin_wait_timeout: Timeout (in seconds) for TCP connections in the FIN_WAIT state. The FIN_WAIT states occur during the normal TCP connection termination process after a FIN packet has been sent. This timeout prevents resources from being held if the connection termination process doesn't complete properly.
        :param _builtins.int last_ack_timeout: Timeout (in seconds) for TCP connections in the LAST_ACK state. The LAST_ACK state occurs during connection termination when the remote end has sent a FIN, the local end has responded with a FIN and ACK, and is waiting for the final ACK from the remote end to complete the connection termination.
        :param _builtins.int syn_recv_timeout: Timeout (in seconds) for TCP connections in the SYN_RECV state. This state occurs during connection establishment after receiving a SYN packet and sending a SYN-ACK, but before receiving the final ACK to complete the three-way handshake. A lower timeout helps mitigate SYN flood attacks by releasing resources for incomplete connections more quickly.
        :param _builtins.int syn_sent_timeout: Timeout (in seconds) for TCP connections in the SYN_SENT state. This state occurs during connection establishment after sending a SYN packet but before receiving a SYN-ACK response. This timeout determines how long the system will wait for a response to connection attempts before giving up.
        :param _builtins.int time_wait_timeout: Timeout (in seconds) for TCP connections in the TIME_WAIT state. The TIME_WAIT state occurs after a connection has been closed but is maintained to ensure any delayed packets are properly handled. The standard recommendation is 2 minutes (120 seconds), but can be reduced in high-connection environments to free resources more quickly at the risk of potential connection issues if delayed packets arrive.
        """
        if close_timeout is not None:
            pulumi.set(__self__, "close_timeout", close_timeout)
        if close_wait_timeout is not None:
            pulumi.set(__self__, "close_wait_timeout", close_wait_timeout)
        if established_timeout is not None:
            pulumi.set(__self__, "established_timeout", established_timeout)
        if fin_wait_timeout is not None:
            pulumi.set(__self__, "fin_wait_timeout", fin_wait_timeout)
        if last_ack_timeout is not None:
            pulumi.set(__self__, "last_ack_timeout", last_ack_timeout)
        if syn_recv_timeout is not None:
            pulumi.set(__self__, "syn_recv_timeout", syn_recv_timeout)
        if syn_sent_timeout is not None:
            pulumi.set(__self__, "syn_sent_timeout", syn_sent_timeout)
        if time_wait_timeout is not None:
            pulumi.set(__self__, "time_wait_timeout", time_wait_timeout)

    @_builtins.property
    @pulumi.getter(name="closeTimeout")
    def close_timeout(self) -> Optional[_builtins.int]:
        """
        Timeout (in seconds) for TCP connections in the CLOSE state. The CLOSE state occurs when a connection is being terminated but may still have packets in transit. Lower values reclaim resources more quickly, while higher values ensure all packets are properly processed during connection termination.
        """
        return pulumi.get(self, "close_timeout")

    @_builtins.property
    @pulumi.getter(name="closeWaitTimeout")
    def close_wait_timeout(self) -> Optional[_builtins.int]:
        """
        Timeout (in seconds) for TCP connections in the CLOSE_WAIT state. The CLOSE_WAIT state occurs when the remote end has initiated connection termination, but the local application hasn't closed the connection yet. This timeout prevents resources from being held indefinitely if a local application fails to properly close its connection.
        """
        return pulumi.get(self, "close_wait_timeout")

    @_builtins.property
    @pulumi.getter(name="establishedTimeout")
    def established_timeout(self) -> Optional[_builtins.int]:
        """
        Timeout (in seconds) for TCP connections in the ESTABLISHED state. This is the most important TCP timeout as it determines how long idle but established connections are maintained in the connection tracking table. Higher values (e.g., 86400 = 24 hours) are suitable for long-lived connections, while lower values conserve resources but may cause issues with applications that maintain idle connections.
        """
        return pulumi.get(self, "established_timeout")

    @_builtins.property
    @pulumi.getter(name="finWaitTimeout")
    def fin_wait_timeout(self) -> Optional[_builtins.int]:
        """
        Timeout (in seconds) for TCP connections in the FIN_WAIT state. The FIN_WAIT states occur during the normal TCP connection termination process after a FIN packet has been sent. This timeout prevents resources from being held if the connection termination process doesn't complete properly.
        """
        return pulumi.get(self, "fin_wait_timeout")

    @_builtins.property
    @pulumi.getter(name="lastAckTimeout")
    def last_ack_timeout(self) -> Optional[_builtins.int]:
        """
        Timeout (in seconds) for TCP connections in the LAST_ACK state. The LAST_ACK state occurs during connection termination when the remote end has sent a FIN, the local end has responded with a FIN and ACK, and is waiting for the final ACK from the remote end to complete the connection termination.
        """
        return pulumi.get(self, "last_ack_timeout")

    @_builtins.property
    @pulumi.getter(name="synRecvTimeout")
    def syn_recv_timeout(self) -> Optional[_builtins.int]:
        """
        Timeout (in seconds) for TCP connections in the SYN_RECV state. This state occurs during connection establishment after receiving a SYN packet and sending a SYN-ACK, but before receiving the final ACK to complete the three-way handshake. A lower timeout helps mitigate SYN flood attacks by releasing resources for incomplete connections more quickly.
        """
        return pulumi.get(self, "syn_recv_timeout")

    @_builtins.property
    @pulumi.getter(name="synSentTimeout")
    def syn_sent_timeout(self) -> Optional[_builtins.int]:
        """
        Timeout (in seconds) for TCP connections in the SYN_SENT state. This state occurs during connection establishment after sending a SYN packet but before receiving a SYN-ACK response. This timeout determines how long the system will wait for a response to connection attempts before giving up.
        """
        return pulumi.get(self, "syn_sent_timeout")

    @_builtins.property
    @pulumi.getter(name="timeWaitTimeout")
    def time_wait_timeout(self) -> Optional[_builtins.int]:
        """
        Timeout (in seconds) for TCP connections in the TIME_WAIT state. The TIME_WAIT state occurs after a connection has been closed but is maintained to ensure any delayed packets are properly handled. The standard recommendation is 2 minutes (120 seconds), but can be reduced in high-connection environments to free resources more quickly at the risk of potential connection issues if delayed packets arrive.
        """
        return pulumi.get(self, "time_wait_timeout")


@pulumi.output_type
class USGUpnp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "natPmpEnabled":
            suggest = "nat_pmp_enabled"
        elif key == "secureMode":
            suggest = "secure_mode"
        elif key == "wanInterface":
            suggest = "wan_interface"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in USGUpnp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        USGUpnp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        USGUpnp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 nat_pmp_enabled: Optional[_builtins.bool] = None,
                 secure_mode: Optional[_builtins.bool] = None,
                 wan_interface: Optional[_builtins.str] = None):
        """
        :param _builtins.bool nat_pmp_enabled: Enable NAT-PMP (NAT Port Mapping Protocol) support alongside UPNP. NAT-PMP is Apple's alternative to UPNP, providing similar automatic port mapping capabilities. When enabled, Apple devices like Macs, iPhones, and iPads can automatically configure port forwarding for services like AirPlay, FaceTime, iMessage, and other Apple services. Defaults to `false`.
        :param _builtins.bool secure_mode: Enable secure mode for UPNP. In secure mode, the gateway only forwards ports to the device that specifically requested them, enhancing security. This prevents malicious applications from redirecting ports to different devices than intended. It's strongly recommended to enable this setting when using UPNP to minimize security risks. Defaults to `false`.
        :param _builtins.str wan_interface: Specify which WAN interface to use for UPNP service. Valid values are:
                 * `WAN` (default) - Use the primary WAN interface for UPNP port forwarding
                 * `WAN2` - Use the secondary WAN interface for UPNP port forwarding (if available)
               
               This setting is particularly relevant for dual-WAN setups where you may want to direct UPNP traffic through a specific WAN connection. If your gateway only has a single WAN interface, use the default `WAN` setting.
        """
        if nat_pmp_enabled is not None:
            pulumi.set(__self__, "nat_pmp_enabled", nat_pmp_enabled)
        if secure_mode is not None:
            pulumi.set(__self__, "secure_mode", secure_mode)
        if wan_interface is not None:
            pulumi.set(__self__, "wan_interface", wan_interface)

    @_builtins.property
    @pulumi.getter(name="natPmpEnabled")
    def nat_pmp_enabled(self) -> Optional[_builtins.bool]:
        """
        Enable NAT-PMP (NAT Port Mapping Protocol) support alongside UPNP. NAT-PMP is Apple's alternative to UPNP, providing similar automatic port mapping capabilities. When enabled, Apple devices like Macs, iPhones, and iPads can automatically configure port forwarding for services like AirPlay, FaceTime, iMessage, and other Apple services. Defaults to `false`.
        """
        return pulumi.get(self, "nat_pmp_enabled")

    @_builtins.property
    @pulumi.getter(name="secureMode")
    def secure_mode(self) -> Optional[_builtins.bool]:
        """
        Enable secure mode for UPNP. In secure mode, the gateway only forwards ports to the device that specifically requested them, enhancing security. This prevents malicious applications from redirecting ports to different devices than intended. It's strongly recommended to enable this setting when using UPNP to minimize security risks. Defaults to `false`.
        """
        return pulumi.get(self, "secure_mode")

    @_builtins.property
    @pulumi.getter(name="wanInterface")
    def wan_interface(self) -> Optional[_builtins.str]:
        """
        Specify which WAN interface to use for UPNP service. Valid values are:
          * `WAN` (default) - Use the primary WAN interface for UPNP port forwarding
          * `WAN2` - Use the secondary WAN interface for UPNP port forwarding (if available)

        This setting is particularly relevant for dual-WAN setups where you may want to direct UPNP traffic through a specific WAN connection. If your gateway only has a single WAN interface, use the default `WAN` setting.
        """
        return pulumi.get(self, "wan_interface")


