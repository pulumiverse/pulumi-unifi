// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package unifi

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-unifi/sdk/go/unifi/internal"
)

// The `Device` resource manages UniFi network devices such as access points, switches, gateways, etc.
//
// Devices must first be adopted by the UniFi controller before they can be managed through Terraform. This resource cannot create new devices, but instead allows you to manage existing devices that have already been adopted. The recommended approach is to adopt devices through the UniFi controller UI first, then import them into Terraform using the device's MAC address.
//
// This resource supports managing device names, port configurations, and other device-specific settings.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumiverse/pulumi-unifi/sdk/go/unifi"
//	"github.com/pulumiverse/pulumi-unifi/sdk/go/unifi/port"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			disabled, err := port.LookupProfile(ctx, &port.LookupProfileArgs{
//				Name: pulumi.StringRef("Disabled"),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			poe, err := port.NewProfile(ctx, "poe", &port.ProfileArgs{
//				Name:                pulumi.String("poe"),
//				Forward:             pulumi.String("customize"),
//				NativeNetworkconfId: pulumi.Any(nativeNetworkId),
//				TaggedNetworkconfIds: []interface{}{
//					someVlanNetworkId,
//				},
//				PoeMode: pulumi.String("auto"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = unifi.NewDevice(ctx, "us_24_poe", &unifi.DeviceArgs{
//				Mac:  pulumi.String("01:23:45:67:89:AB"),
//				Name: pulumi.String("Switch with POE"),
//				PortOverrides: unifi.DevicePortOverrideArray{
//					&unifi.DevicePortOverrideArgs{
//						Number:        pulumi.Int(1),
//						Name:          pulumi.String("port w/ poe"),
//						PortProfileId: poe.ID(),
//					},
//					&unifi.DevicePortOverrideArgs{
//						Number:        pulumi.Int(2),
//						Name:          pulumi.String("disabled"),
//						PortProfileId: pulumi.String(disabled.Id),
//					},
//					&unifi.DevicePortOverrideArgs{
//						Number:            pulumi.Int(11),
//						OpMode:            pulumi.String("aggregate"),
//						AggregateNumPorts: pulumi.Int(2),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type Device struct {
	pulumi.CustomResourceState

	// Whether to automatically adopt the device when creating this resource. When true:
	// * The controller will attempt to adopt the device
	// * Device must be in a pending adoption state
	// * Device must be accessible on the network
	//   Set to false if you want to manage adoption manually.
	AllowAdoption pulumi.BoolPtrOutput `pulumi:"allowAdoption"`
	// Whether the device is administratively disabled. When true, the device will not forward traffic or provide services.
	Disabled pulumi.BoolOutput `pulumi:"disabled"`
	// Whether to forget (un-adopt) the device when this resource is destroyed. When true:
	// * The device will be removed from the controller
	// * The device will need to be readopted to be managed again
	// * Device configuration will be reset
	//   Set to false to keep the device adopted when removing from Terraform management.
	ForgetOnDestroy pulumi.BoolPtrOutput `pulumi:"forgetOnDestroy"`
	// The MAC address of the device in standard format (e.g., 'aa:bb:cc:dd:ee:ff'). This is used to identify and manage specific devices that have already been adopted by the controller.
	Mac pulumi.StringOutput `pulumi:"mac"`
	// A friendly name for the device that will be displayed in the UniFi controller UI. Examples:
	// * 'Office-AP-1' for an access point
	// * 'Core-Switch-01' for a switch
	// * 'Main-Gateway' for a gateway
	//   Choose descriptive names that indicate location and purpose.
	Name pulumi.StringOutput `pulumi:"name"`
	// A list of port-specific configuration overrides for UniFi switches. This allows you to customize individual port settings such as:
	//   * Port names and labels for easy identification
	//   * Port profiles for VLAN and security settings
	//   * Operating modes for special functions
	//
	// Common use cases include:
	//   * Setting up trunk ports for inter-switch connections
	//   * Configuring PoE settings for powered devices
	//   * Creating mirrored ports for network monitoring
	//   * Setting up link aggregation between switches or servers
	PortOverrides DevicePortOverrideArrayOutput `pulumi:"portOverrides"`
	// The name of the UniFi site where the device is located. If not specified, the default site will be used.
	Site pulumi.StringOutput `pulumi:"site"`
}

// NewDevice registers a new resource with the given unique name, arguments, and options.
func NewDevice(ctx *pulumi.Context,
	name string, args *DeviceArgs, opts ...pulumi.ResourceOption) (*Device, error) {
	if args == nil {
		args = &DeviceArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Device
	err := ctx.RegisterResource("unifi:index/device:Device", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDevice gets an existing Device resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDevice(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DeviceState, opts ...pulumi.ResourceOption) (*Device, error) {
	var resource Device
	err := ctx.ReadResource("unifi:index/device:Device", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Device resources.
type deviceState struct {
	// Whether to automatically adopt the device when creating this resource. When true:
	// * The controller will attempt to adopt the device
	// * Device must be in a pending adoption state
	// * Device must be accessible on the network
	//   Set to false if you want to manage adoption manually.
	AllowAdoption *bool `pulumi:"allowAdoption"`
	// Whether the device is administratively disabled. When true, the device will not forward traffic or provide services.
	Disabled *bool `pulumi:"disabled"`
	// Whether to forget (un-adopt) the device when this resource is destroyed. When true:
	// * The device will be removed from the controller
	// * The device will need to be readopted to be managed again
	// * Device configuration will be reset
	//   Set to false to keep the device adopted when removing from Terraform management.
	ForgetOnDestroy *bool `pulumi:"forgetOnDestroy"`
	// The MAC address of the device in standard format (e.g., 'aa:bb:cc:dd:ee:ff'). This is used to identify and manage specific devices that have already been adopted by the controller.
	Mac *string `pulumi:"mac"`
	// A friendly name for the device that will be displayed in the UniFi controller UI. Examples:
	// * 'Office-AP-1' for an access point
	// * 'Core-Switch-01' for a switch
	// * 'Main-Gateway' for a gateway
	//   Choose descriptive names that indicate location and purpose.
	Name *string `pulumi:"name"`
	// A list of port-specific configuration overrides for UniFi switches. This allows you to customize individual port settings such as:
	//   * Port names and labels for easy identification
	//   * Port profiles for VLAN and security settings
	//   * Operating modes for special functions
	//
	// Common use cases include:
	//   * Setting up trunk ports for inter-switch connections
	//   * Configuring PoE settings for powered devices
	//   * Creating mirrored ports for network monitoring
	//   * Setting up link aggregation between switches or servers
	PortOverrides []DevicePortOverride `pulumi:"portOverrides"`
	// The name of the UniFi site where the device is located. If not specified, the default site will be used.
	Site *string `pulumi:"site"`
}

type DeviceState struct {
	// Whether to automatically adopt the device when creating this resource. When true:
	// * The controller will attempt to adopt the device
	// * Device must be in a pending adoption state
	// * Device must be accessible on the network
	//   Set to false if you want to manage adoption manually.
	AllowAdoption pulumi.BoolPtrInput
	// Whether the device is administratively disabled. When true, the device will not forward traffic or provide services.
	Disabled pulumi.BoolPtrInput
	// Whether to forget (un-adopt) the device when this resource is destroyed. When true:
	// * The device will be removed from the controller
	// * The device will need to be readopted to be managed again
	// * Device configuration will be reset
	//   Set to false to keep the device adopted when removing from Terraform management.
	ForgetOnDestroy pulumi.BoolPtrInput
	// The MAC address of the device in standard format (e.g., 'aa:bb:cc:dd:ee:ff'). This is used to identify and manage specific devices that have already been adopted by the controller.
	Mac pulumi.StringPtrInput
	// A friendly name for the device that will be displayed in the UniFi controller UI. Examples:
	// * 'Office-AP-1' for an access point
	// * 'Core-Switch-01' for a switch
	// * 'Main-Gateway' for a gateway
	//   Choose descriptive names that indicate location and purpose.
	Name pulumi.StringPtrInput
	// A list of port-specific configuration overrides for UniFi switches. This allows you to customize individual port settings such as:
	//   * Port names and labels for easy identification
	//   * Port profiles for VLAN and security settings
	//   * Operating modes for special functions
	//
	// Common use cases include:
	//   * Setting up trunk ports for inter-switch connections
	//   * Configuring PoE settings for powered devices
	//   * Creating mirrored ports for network monitoring
	//   * Setting up link aggregation between switches or servers
	PortOverrides DevicePortOverrideArrayInput
	// The name of the UniFi site where the device is located. If not specified, the default site will be used.
	Site pulumi.StringPtrInput
}

func (DeviceState) ElementType() reflect.Type {
	return reflect.TypeOf((*deviceState)(nil)).Elem()
}

type deviceArgs struct {
	// Whether to automatically adopt the device when creating this resource. When true:
	// * The controller will attempt to adopt the device
	// * Device must be in a pending adoption state
	// * Device must be accessible on the network
	//   Set to false if you want to manage adoption manually.
	AllowAdoption *bool `pulumi:"allowAdoption"`
	// Whether to forget (un-adopt) the device when this resource is destroyed. When true:
	// * The device will be removed from the controller
	// * The device will need to be readopted to be managed again
	// * Device configuration will be reset
	//   Set to false to keep the device adopted when removing from Terraform management.
	ForgetOnDestroy *bool `pulumi:"forgetOnDestroy"`
	// The MAC address of the device in standard format (e.g., 'aa:bb:cc:dd:ee:ff'). This is used to identify and manage specific devices that have already been adopted by the controller.
	Mac *string `pulumi:"mac"`
	// A friendly name for the device that will be displayed in the UniFi controller UI. Examples:
	// * 'Office-AP-1' for an access point
	// * 'Core-Switch-01' for a switch
	// * 'Main-Gateway' for a gateway
	//   Choose descriptive names that indicate location and purpose.
	Name *string `pulumi:"name"`
	// A list of port-specific configuration overrides for UniFi switches. This allows you to customize individual port settings such as:
	//   * Port names and labels for easy identification
	//   * Port profiles for VLAN and security settings
	//   * Operating modes for special functions
	//
	// Common use cases include:
	//   * Setting up trunk ports for inter-switch connections
	//   * Configuring PoE settings for powered devices
	//   * Creating mirrored ports for network monitoring
	//   * Setting up link aggregation between switches or servers
	PortOverrides []DevicePortOverride `pulumi:"portOverrides"`
	// The name of the UniFi site where the device is located. If not specified, the default site will be used.
	Site *string `pulumi:"site"`
}

// The set of arguments for constructing a Device resource.
type DeviceArgs struct {
	// Whether to automatically adopt the device when creating this resource. When true:
	// * The controller will attempt to adopt the device
	// * Device must be in a pending adoption state
	// * Device must be accessible on the network
	//   Set to false if you want to manage adoption manually.
	AllowAdoption pulumi.BoolPtrInput
	// Whether to forget (un-adopt) the device when this resource is destroyed. When true:
	// * The device will be removed from the controller
	// * The device will need to be readopted to be managed again
	// * Device configuration will be reset
	//   Set to false to keep the device adopted when removing from Terraform management.
	ForgetOnDestroy pulumi.BoolPtrInput
	// The MAC address of the device in standard format (e.g., 'aa:bb:cc:dd:ee:ff'). This is used to identify and manage specific devices that have already been adopted by the controller.
	Mac pulumi.StringPtrInput
	// A friendly name for the device that will be displayed in the UniFi controller UI. Examples:
	// * 'Office-AP-1' for an access point
	// * 'Core-Switch-01' for a switch
	// * 'Main-Gateway' for a gateway
	//   Choose descriptive names that indicate location and purpose.
	Name pulumi.StringPtrInput
	// A list of port-specific configuration overrides for UniFi switches. This allows you to customize individual port settings such as:
	//   * Port names and labels for easy identification
	//   * Port profiles for VLAN and security settings
	//   * Operating modes for special functions
	//
	// Common use cases include:
	//   * Setting up trunk ports for inter-switch connections
	//   * Configuring PoE settings for powered devices
	//   * Creating mirrored ports for network monitoring
	//   * Setting up link aggregation between switches or servers
	PortOverrides DevicePortOverrideArrayInput
	// The name of the UniFi site where the device is located. If not specified, the default site will be used.
	Site pulumi.StringPtrInput
}

func (DeviceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*deviceArgs)(nil)).Elem()
}

type DeviceInput interface {
	pulumi.Input

	ToDeviceOutput() DeviceOutput
	ToDeviceOutputWithContext(ctx context.Context) DeviceOutput
}

func (*Device) ElementType() reflect.Type {
	return reflect.TypeOf((**Device)(nil)).Elem()
}

func (i *Device) ToDeviceOutput() DeviceOutput {
	return i.ToDeviceOutputWithContext(context.Background())
}

func (i *Device) ToDeviceOutputWithContext(ctx context.Context) DeviceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceOutput)
}

// DeviceArrayInput is an input type that accepts DeviceArray and DeviceArrayOutput values.
// You can construct a concrete instance of `DeviceArrayInput` via:
//
//	DeviceArray{ DeviceArgs{...} }
type DeviceArrayInput interface {
	pulumi.Input

	ToDeviceArrayOutput() DeviceArrayOutput
	ToDeviceArrayOutputWithContext(context.Context) DeviceArrayOutput
}

type DeviceArray []DeviceInput

func (DeviceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Device)(nil)).Elem()
}

func (i DeviceArray) ToDeviceArrayOutput() DeviceArrayOutput {
	return i.ToDeviceArrayOutputWithContext(context.Background())
}

func (i DeviceArray) ToDeviceArrayOutputWithContext(ctx context.Context) DeviceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceArrayOutput)
}

// DeviceMapInput is an input type that accepts DeviceMap and DeviceMapOutput values.
// You can construct a concrete instance of `DeviceMapInput` via:
//
//	DeviceMap{ "key": DeviceArgs{...} }
type DeviceMapInput interface {
	pulumi.Input

	ToDeviceMapOutput() DeviceMapOutput
	ToDeviceMapOutputWithContext(context.Context) DeviceMapOutput
}

type DeviceMap map[string]DeviceInput

func (DeviceMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Device)(nil)).Elem()
}

func (i DeviceMap) ToDeviceMapOutput() DeviceMapOutput {
	return i.ToDeviceMapOutputWithContext(context.Background())
}

func (i DeviceMap) ToDeviceMapOutputWithContext(ctx context.Context) DeviceMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceMapOutput)
}

type DeviceOutput struct{ *pulumi.OutputState }

func (DeviceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Device)(nil)).Elem()
}

func (o DeviceOutput) ToDeviceOutput() DeviceOutput {
	return o
}

func (o DeviceOutput) ToDeviceOutputWithContext(ctx context.Context) DeviceOutput {
	return o
}

// Whether to automatically adopt the device when creating this resource. When true:
//   - The controller will attempt to adopt the device
//   - Device must be in a pending adoption state
//   - Device must be accessible on the network
//     Set to false if you want to manage adoption manually.
func (o DeviceOutput) AllowAdoption() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Device) pulumi.BoolPtrOutput { return v.AllowAdoption }).(pulumi.BoolPtrOutput)
}

// Whether the device is administratively disabled. When true, the device will not forward traffic or provide services.
func (o DeviceOutput) Disabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *Device) pulumi.BoolOutput { return v.Disabled }).(pulumi.BoolOutput)
}

// Whether to forget (un-adopt) the device when this resource is destroyed. When true:
//   - The device will be removed from the controller
//   - The device will need to be readopted to be managed again
//   - Device configuration will be reset
//     Set to false to keep the device adopted when removing from Terraform management.
func (o DeviceOutput) ForgetOnDestroy() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Device) pulumi.BoolPtrOutput { return v.ForgetOnDestroy }).(pulumi.BoolPtrOutput)
}

// The MAC address of the device in standard format (e.g., 'aa:bb:cc:dd:ee:ff'). This is used to identify and manage specific devices that have already been adopted by the controller.
func (o DeviceOutput) Mac() pulumi.StringOutput {
	return o.ApplyT(func(v *Device) pulumi.StringOutput { return v.Mac }).(pulumi.StringOutput)
}

// A friendly name for the device that will be displayed in the UniFi controller UI. Examples:
//   - 'Office-AP-1' for an access point
//   - 'Core-Switch-01' for a switch
//   - 'Main-Gateway' for a gateway
//     Choose descriptive names that indicate location and purpose.
func (o DeviceOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Device) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// A list of port-specific configuration overrides for UniFi switches. This allows you to customize individual port settings such as:
//   - Port names and labels for easy identification
//   - Port profiles for VLAN and security settings
//   - Operating modes for special functions
//
// Common use cases include:
//   - Setting up trunk ports for inter-switch connections
//   - Configuring PoE settings for powered devices
//   - Creating mirrored ports for network monitoring
//   - Setting up link aggregation between switches or servers
func (o DeviceOutput) PortOverrides() DevicePortOverrideArrayOutput {
	return o.ApplyT(func(v *Device) DevicePortOverrideArrayOutput { return v.PortOverrides }).(DevicePortOverrideArrayOutput)
}

// The name of the UniFi site where the device is located. If not specified, the default site will be used.
func (o DeviceOutput) Site() pulumi.StringOutput {
	return o.ApplyT(func(v *Device) pulumi.StringOutput { return v.Site }).(pulumi.StringOutput)
}

type DeviceArrayOutput struct{ *pulumi.OutputState }

func (DeviceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Device)(nil)).Elem()
}

func (o DeviceArrayOutput) ToDeviceArrayOutput() DeviceArrayOutput {
	return o
}

func (o DeviceArrayOutput) ToDeviceArrayOutputWithContext(ctx context.Context) DeviceArrayOutput {
	return o
}

func (o DeviceArrayOutput) Index(i pulumi.IntInput) DeviceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Device {
		return vs[0].([]*Device)[vs[1].(int)]
	}).(DeviceOutput)
}

type DeviceMapOutput struct{ *pulumi.OutputState }

func (DeviceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Device)(nil)).Elem()
}

func (o DeviceMapOutput) ToDeviceMapOutput() DeviceMapOutput {
	return o
}

func (o DeviceMapOutput) ToDeviceMapOutputWithContext(ctx context.Context) DeviceMapOutput {
	return o
}

func (o DeviceMapOutput) MapIndex(k pulumi.StringInput) DeviceOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Device {
		return vs[0].(map[string]*Device)[vs[1].(string)]
	}).(DeviceOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceInput)(nil)).Elem(), &Device{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceArrayInput)(nil)).Elem(), DeviceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceMapInput)(nil)).Elem(), DeviceMap{})
	pulumi.RegisterOutputType(DeviceOutput{})
	pulumi.RegisterOutputType(DeviceArrayOutput{})
	pulumi.RegisterOutputType(DeviceMapOutput{})
}
