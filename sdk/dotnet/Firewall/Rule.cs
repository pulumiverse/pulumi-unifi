// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace Pulumiverse.Unifi.Firewall
{
    /// <summary>
    /// The `unifi.firewall.Rule` resource manages firewall rules.
    /// 
    /// This resource allows you to create and manage firewall rules that control traffic flow between different network segments (WAN, LAN, Guest) for both IPv4 and IPv6 traffic. Rules can be configured to allow, drop, or reject traffic based on various criteria including protocols, ports, and IP addresses.
    /// 
    /// Rules are processed in order based on their `RuleIndex`, with lower numbers being processed first. Custom rules should use indices between 2000-2999 or 4000-4999 to avoid conflicts with system rules.
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Unifi = Pulumiverse.Unifi;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var config = new Config();
    ///     var ipAddress = config.Require("ipAddress");
    ///     var dropAll = new Unifi.Firewall.Rule("drop_all", new()
    ///     {
    ///         Name = "drop all",
    ///         Action = "drop",
    ///         Ruleset = "LAN_IN",
    ///         RuleIndex = 2011,
    ///         Protocol = "all",
    ///         DstAddress = ipAddress,
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// import using the ID from the controller API/UI
    /// 
    /// ```sh
    /// $ pulumi import unifi:firewall/rule:Rule my_rule 5f7080eb6b8969064f80494f
    /// ```
    /// </summary>
    [UnifiResourceType("unifi:firewall/rule:Rule")]
    public partial class Rule : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The action to take when traffic matches this rule. Valid values are:
        ///   * `Accept` - Allow the traffic
        ///   * `Drop` - Silently block the traffic
        ///   * `Reject` - Block the traffic and send an ICMP rejection message
        /// </summary>
        [Output("action")]
        public Output<string> Action { get; private set; } = null!;

        /// <summary>
        /// The destination IPv4 address or network in CIDR notation (e.g., '192.168.1.10' or '192.168.0.0/24'). The format must match DstNetworkType - use a single IP for ADDRv4 or CIDR for NETv4.
        /// </summary>
        [Output("dstAddress")]
        public Output<string?> DstAddress { get; private set; } = null!;

        /// <summary>
        /// The destination IPv6 address or network in CIDR notation (e.g., '2001:db8::1' or '2001:db8::/64'). Used for IPv6 firewall rules.
        /// </summary>
        [Output("dstAddressIpv6")]
        public Output<string?> DstAddressIpv6 { get; private set; } = null!;

        /// <summary>
        /// A list of firewall group IDs to use as destinations. Groups can contain IP addresses, networks, or port numbers. This allows you to create reusable sets of addresses/ports and reference them in multiple rules.
        /// </summary>
        [Output("dstFirewallGroupIds")]
        public Output<ImmutableArray<string>> DstFirewallGroupIds { get; private set; } = null!;

        /// <summary>
        /// The ID of the destination network this rule applies to. This can be found in the URL when viewing the network in the UniFi controller.
        /// </summary>
        [Output("dstNetworkId")]
        public Output<string?> DstNetworkId { get; private set; } = null!;

        /// <summary>
        /// The type of destination network address. Valid values are:
        ///   * `ADDRv4` - Single IPv4 address
        ///   * `NETv4` - IPv4 network in CIDR notation
        /// </summary>
        [Output("dstNetworkType")]
        public Output<string?> DstNetworkType { get; private set; } = null!;

        /// <summary>
        /// The destination port(s) for this rule. Can be:
        ///   * A single port number (e.g., '80')
        ///   * A port range (e.g., '8000:8080')
        ///   * A list of ports/ranges separated by commas
        /// </summary>
        [Output("dstPort")]
        public Output<string?> DstPort { get; private set; } = null!;

        /// <summary>
        /// Whether this firewall rule is active (true) or disabled (false). Defaults to true.
        /// </summary>
        [Output("enabled")]
        public Output<bool?> Enabled { get; private set; } = null!;

        /// <summary>
        /// The ICMP type name when protocol is set to 'icmp'. Common values include:
        ///   * `echo-request` - ICMP ping requests
        ///   * `echo-reply` - ICMP ping replies
        ///   * `destination-unreachable` - Host/network unreachable messages
        ///   * `time-exceeded` - TTL exceeded messages (traceroute)
        /// </summary>
        [Output("icmpTypename")]
        public Output<string?> IcmpTypename { get; private set; } = null!;

        /// <summary>
        /// The ICMPv6 type name when ProtocolV6 is set to 'ipv6-icmp'. Common values (not all are listed) include:
        ///   * `echo-request` - IPv6 ping requests
        ///   * `echo-reply` - IPv6 ping replies
        ///   * `neighbor-solicitation` - IPv6 neighbor discovery
        ///   * `neighbor-advertisement` - IPv6 neighbor announcements
        ///   * `destination-unreachable` - Host/network unreachable messages
        ///   * `packet-too-big` - Path MTU discovery messages
        /// </summary>
        [Output("icmpV6Typename")]
        public Output<string?> IcmpV6Typename { get; private set; } = null!;

        /// <summary>
        /// Specify whether the rule matches on IPsec packets. Can be one of `match-ipsec` or `match-none`.
        /// </summary>
        [Output("ipSec")]
        public Output<string?> IpSec { get; private set; } = null!;

        /// <summary>
        /// Enable logging for the firewall rule.
        /// </summary>
        [Output("logging")]
        public Output<bool?> Logging { get; private set; } = null!;

        /// <summary>
        /// A friendly name for the firewall rule. This helps identify the rule's purpose in the UniFi controller UI.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// The IPv4 protocol this rule applies to. Common values (not all are listed) include:
        ///   * `All` - Match all protocols
        ///   * `Tcp` - TCP traffic only (e.g., web, email)
        ///   * `Udp` - UDP traffic only (e.g., DNS, VoIP)
        ///   * `TcpUdp` - Both TCP and UDP
        ///   * `Icmp` - ICMP traffic (ping, traceroute)
        ///   * Protocol numbers (1-255) for other protocols
        /// 
        /// Examples:
        ///   * Use 'tcp' for web server rules (ports 80, 443)
        ///   * Use 'udp' for VoIP or gaming traffic
        ///   * Use 'all' for general network access rules
        /// </summary>
        [Output("protocol")]
        public Output<string?> Protocol { get; private set; } = null!;

        /// <summary>
        /// The IPv6 protocol this rule applies to. Similar to 'protocol' but for IPv6 traffic. Common values (not all are listed) include:
        ///   * `All` - Match all protocols
        ///   * `Tcp` - TCP traffic only
        ///   * `Udp` - UDP traffic only
        ///   * `TcpUdp` - Both TCP and UDP traffic
        ///   * `ipv6-icmp` - ICMPv6 traffic
        /// </summary>
        [Output("protocolV6")]
        public Output<string?> ProtocolV6 { get; private set; } = null!;

        /// <summary>
        /// The processing order for this rule. Lower numbers are processed first. Custom rules should use:
        ///   * 2000-2999 for rules processed before auto-generated rules
        ///   * 4000-4999 for rules processed after auto-generated rules
        /// </summary>
        [Output("ruleIndex")]
        public Output<int> RuleIndex { get; private set; } = null!;

        /// <summary>
        /// Defines which traffic flow this rule applies to. The format is [NETWORK]_[DIRECTION], where:
        ///   * NETWORK can be: WAN, LAN, GUEST (or their IPv6 variants WANv6, LANv6, GUESTv6)
        ///   * DIRECTION can be:
        ///     * IN - Traffic entering the network
        ///     * OUT - Traffic leaving the network
        ///     * LOCAL - Traffic destined for the USG/UDM itself
        /// 
        /// Examples: WAN_IN (incoming WAN traffic), LAN_OUT (outgoing LAN traffic), GUEST_LOCAL (traffic to Controller from guest network)
        /// </summary>
        [Output("ruleset")]
        public Output<string> Ruleset { get; private set; } = null!;

        /// <summary>
        /// The name of the UniFi site where the firewall rule should be created. If not specified, the default site will be used.
        /// </summary>
        [Output("site")]
        public Output<string> Site { get; private set; } = null!;

        /// <summary>
        /// The source IPv4 address for the firewall rule.
        /// </summary>
        [Output("srcAddress")]
        public Output<string?> SrcAddress { get; private set; } = null!;

        /// <summary>
        /// The source IPv6 address or network in CIDR notation (e.g., '2001:db8::1' or '2001:db8::/64'). Used for IPv6 firewall rules.
        /// </summary>
        [Output("srcAddressIpv6")]
        public Output<string?> SrcAddressIpv6 { get; private set; } = null!;

        /// <summary>
        /// A list of firewall group IDs to use as sources. Groups can contain:
        ///   * IP Address Groups - For matching specific IP addresses
        ///   * Network Groups - For matching entire subnets
        ///   * Port Groups - For matching specific port numbers
        /// 
        /// Example uses:
        ///   * Group of trusted admin IPs for remote access
        ///   * Group of IoT device networks for isolation
        ///   * Group of common service ports for allowing specific applications
        /// </summary>
        [Output("srcFirewallGroupIds")]
        public Output<ImmutableArray<string>> SrcFirewallGroupIds { get; private set; } = null!;

        /// <summary>
        /// The source MAC address this rule applies to. Use this to create rules that match specific devices regardless of their IP address. Format: 'XX:XX:XX:XX:XX:XX'. MAC addresses are case-insensitive.
        /// </summary>
        [Output("srcMac")]
        public Output<string?> SrcMac { get; private set; } = null!;

        /// <summary>
        /// The ID of the source network this rule applies to. This can be found in the URL when viewing the network in the UniFi controller, or by using the network's name in the form `[site]/[NetworkName]`.
        /// </summary>
        [Output("srcNetworkId")]
        public Output<string?> SrcNetworkId { get; private set; } = null!;

        /// <summary>
        /// The type of source network address. Valid values are:
        ///   * `ADDRv4` - Single IPv4 address
        ///   * `NETv4` - IPv4 network in CIDR notation
        /// </summary>
        [Output("srcNetworkType")]
        public Output<string?> SrcNetworkType { get; private set; } = null!;

        /// <summary>
        /// The source port(s) for this rule. Can be:
        ///   * A single port number (e.g., '80')
        ///   * A port range (e.g., '8000:8080')
        ///   * A list of ports/ranges separated by commas
        /// </summary>
        [Output("srcPort")]
        public Output<string?> SrcPort { get; private set; } = null!;

        /// <summary>
        /// Match established connections. When enabled:
        ///   * Rule only applies to packets that are part of an existing connection
        ///   * Useful for allowing return traffic without creating separate rules
        ///   * Common in WAN_IN rules to allow responses to outbound connections
        /// 
        /// Example: Allow established connections from WAN while blocking new incoming connections
        /// </summary>
        [Output("stateEstablished")]
        public Output<bool?> StateEstablished { get; private set; } = null!;

        /// <summary>
        /// Match where the state is invalid.
        /// </summary>
        [Output("stateInvalid")]
        public Output<bool?> StateInvalid { get; private set; } = null!;

        /// <summary>
        /// Match where the state is new.
        /// </summary>
        [Output("stateNew")]
        public Output<bool?> StateNew { get; private set; } = null!;

        /// <summary>
        /// Match where the state is related.
        /// </summary>
        [Output("stateRelated")]
        public Output<bool?> StateRelated { get; private set; } = null!;


        /// <summary>
        /// Create a Rule resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Rule(string name, RuleArgs args, CustomResourceOptions? options = null)
            : base("unifi:firewall/rule:Rule", name, args ?? new RuleArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Rule(string name, Input<string> id, RuleState? state = null, CustomResourceOptions? options = null)
            : base("unifi:firewall/rule:Rule", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "github://api.github.com/pulumiverse",
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Rule resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Rule Get(string name, Input<string> id, RuleState? state = null, CustomResourceOptions? options = null)
        {
            return new Rule(name, id, state, options);
        }
    }

    public sealed class RuleArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The action to take when traffic matches this rule. Valid values are:
        ///   * `Accept` - Allow the traffic
        ///   * `Drop` - Silently block the traffic
        ///   * `Reject` - Block the traffic and send an ICMP rejection message
        /// </summary>
        [Input("action", required: true)]
        public Input<string> Action { get; set; } = null!;

        /// <summary>
        /// The destination IPv4 address or network in CIDR notation (e.g., '192.168.1.10' or '192.168.0.0/24'). The format must match DstNetworkType - use a single IP for ADDRv4 or CIDR for NETv4.
        /// </summary>
        [Input("dstAddress")]
        public Input<string>? DstAddress { get; set; }

        /// <summary>
        /// The destination IPv6 address or network in CIDR notation (e.g., '2001:db8::1' or '2001:db8::/64'). Used for IPv6 firewall rules.
        /// </summary>
        [Input("dstAddressIpv6")]
        public Input<string>? DstAddressIpv6 { get; set; }

        [Input("dstFirewallGroupIds")]
        private InputList<string>? _dstFirewallGroupIds;

        /// <summary>
        /// A list of firewall group IDs to use as destinations. Groups can contain IP addresses, networks, or port numbers. This allows you to create reusable sets of addresses/ports and reference them in multiple rules.
        /// </summary>
        public InputList<string> DstFirewallGroupIds
        {
            get => _dstFirewallGroupIds ?? (_dstFirewallGroupIds = new InputList<string>());
            set => _dstFirewallGroupIds = value;
        }

        /// <summary>
        /// The ID of the destination network this rule applies to. This can be found in the URL when viewing the network in the UniFi controller.
        /// </summary>
        [Input("dstNetworkId")]
        public Input<string>? DstNetworkId { get; set; }

        /// <summary>
        /// The type of destination network address. Valid values are:
        ///   * `ADDRv4` - Single IPv4 address
        ///   * `NETv4` - IPv4 network in CIDR notation
        /// </summary>
        [Input("dstNetworkType")]
        public Input<string>? DstNetworkType { get; set; }

        /// <summary>
        /// The destination port(s) for this rule. Can be:
        ///   * A single port number (e.g., '80')
        ///   * A port range (e.g., '8000:8080')
        ///   * A list of ports/ranges separated by commas
        /// </summary>
        [Input("dstPort")]
        public Input<string>? DstPort { get; set; }

        /// <summary>
        /// Whether this firewall rule is active (true) or disabled (false). Defaults to true.
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        /// <summary>
        /// The ICMP type name when protocol is set to 'icmp'. Common values include:
        ///   * `echo-request` - ICMP ping requests
        ///   * `echo-reply` - ICMP ping replies
        ///   * `destination-unreachable` - Host/network unreachable messages
        ///   * `time-exceeded` - TTL exceeded messages (traceroute)
        /// </summary>
        [Input("icmpTypename")]
        public Input<string>? IcmpTypename { get; set; }

        /// <summary>
        /// The ICMPv6 type name when ProtocolV6 is set to 'ipv6-icmp'. Common values (not all are listed) include:
        ///   * `echo-request` - IPv6 ping requests
        ///   * `echo-reply` - IPv6 ping replies
        ///   * `neighbor-solicitation` - IPv6 neighbor discovery
        ///   * `neighbor-advertisement` - IPv6 neighbor announcements
        ///   * `destination-unreachable` - Host/network unreachable messages
        ///   * `packet-too-big` - Path MTU discovery messages
        /// </summary>
        [Input("icmpV6Typename")]
        public Input<string>? IcmpV6Typename { get; set; }

        /// <summary>
        /// Specify whether the rule matches on IPsec packets. Can be one of `match-ipsec` or `match-none`.
        /// </summary>
        [Input("ipSec")]
        public Input<string>? IpSec { get; set; }

        /// <summary>
        /// Enable logging for the firewall rule.
        /// </summary>
        [Input("logging")]
        public Input<bool>? Logging { get; set; }

        /// <summary>
        /// A friendly name for the firewall rule. This helps identify the rule's purpose in the UniFi controller UI.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The IPv4 protocol this rule applies to. Common values (not all are listed) include:
        ///   * `All` - Match all protocols
        ///   * `Tcp` - TCP traffic only (e.g., web, email)
        ///   * `Udp` - UDP traffic only (e.g., DNS, VoIP)
        ///   * `TcpUdp` - Both TCP and UDP
        ///   * `Icmp` - ICMP traffic (ping, traceroute)
        ///   * Protocol numbers (1-255) for other protocols
        /// 
        /// Examples:
        ///   * Use 'tcp' for web server rules (ports 80, 443)
        ///   * Use 'udp' for VoIP or gaming traffic
        ///   * Use 'all' for general network access rules
        /// </summary>
        [Input("protocol")]
        public Input<string>? Protocol { get; set; }

        /// <summary>
        /// The IPv6 protocol this rule applies to. Similar to 'protocol' but for IPv6 traffic. Common values (not all are listed) include:
        ///   * `All` - Match all protocols
        ///   * `Tcp` - TCP traffic only
        ///   * `Udp` - UDP traffic only
        ///   * `TcpUdp` - Both TCP and UDP traffic
        ///   * `ipv6-icmp` - ICMPv6 traffic
        /// </summary>
        [Input("protocolV6")]
        public Input<string>? ProtocolV6 { get; set; }

        /// <summary>
        /// The processing order for this rule. Lower numbers are processed first. Custom rules should use:
        ///   * 2000-2999 for rules processed before auto-generated rules
        ///   * 4000-4999 for rules processed after auto-generated rules
        /// </summary>
        [Input("ruleIndex", required: true)]
        public Input<int> RuleIndex { get; set; } = null!;

        /// <summary>
        /// Defines which traffic flow this rule applies to. The format is [NETWORK]_[DIRECTION], where:
        ///   * NETWORK can be: WAN, LAN, GUEST (or their IPv6 variants WANv6, LANv6, GUESTv6)
        ///   * DIRECTION can be:
        ///     * IN - Traffic entering the network
        ///     * OUT - Traffic leaving the network
        ///     * LOCAL - Traffic destined for the USG/UDM itself
        /// 
        /// Examples: WAN_IN (incoming WAN traffic), LAN_OUT (outgoing LAN traffic), GUEST_LOCAL (traffic to Controller from guest network)
        /// </summary>
        [Input("ruleset", required: true)]
        public Input<string> Ruleset { get; set; } = null!;

        /// <summary>
        /// The name of the UniFi site where the firewall rule should be created. If not specified, the default site will be used.
        /// </summary>
        [Input("site")]
        public Input<string>? Site { get; set; }

        /// <summary>
        /// The source IPv4 address for the firewall rule.
        /// </summary>
        [Input("srcAddress")]
        public Input<string>? SrcAddress { get; set; }

        /// <summary>
        /// The source IPv6 address or network in CIDR notation (e.g., '2001:db8::1' or '2001:db8::/64'). Used for IPv6 firewall rules.
        /// </summary>
        [Input("srcAddressIpv6")]
        public Input<string>? SrcAddressIpv6 { get; set; }

        [Input("srcFirewallGroupIds")]
        private InputList<string>? _srcFirewallGroupIds;

        /// <summary>
        /// A list of firewall group IDs to use as sources. Groups can contain:
        ///   * IP Address Groups - For matching specific IP addresses
        ///   * Network Groups - For matching entire subnets
        ///   * Port Groups - For matching specific port numbers
        /// 
        /// Example uses:
        ///   * Group of trusted admin IPs for remote access
        ///   * Group of IoT device networks for isolation
        ///   * Group of common service ports for allowing specific applications
        /// </summary>
        public InputList<string> SrcFirewallGroupIds
        {
            get => _srcFirewallGroupIds ?? (_srcFirewallGroupIds = new InputList<string>());
            set => _srcFirewallGroupIds = value;
        }

        /// <summary>
        /// The source MAC address this rule applies to. Use this to create rules that match specific devices regardless of their IP address. Format: 'XX:XX:XX:XX:XX:XX'. MAC addresses are case-insensitive.
        /// </summary>
        [Input("srcMac")]
        public Input<string>? SrcMac { get; set; }

        /// <summary>
        /// The ID of the source network this rule applies to. This can be found in the URL when viewing the network in the UniFi controller, or by using the network's name in the form `[site]/[NetworkName]`.
        /// </summary>
        [Input("srcNetworkId")]
        public Input<string>? SrcNetworkId { get; set; }

        /// <summary>
        /// The type of source network address. Valid values are:
        ///   * `ADDRv4` - Single IPv4 address
        ///   * `NETv4` - IPv4 network in CIDR notation
        /// </summary>
        [Input("srcNetworkType")]
        public Input<string>? SrcNetworkType { get; set; }

        /// <summary>
        /// The source port(s) for this rule. Can be:
        ///   * A single port number (e.g., '80')
        ///   * A port range (e.g., '8000:8080')
        ///   * A list of ports/ranges separated by commas
        /// </summary>
        [Input("srcPort")]
        public Input<string>? SrcPort { get; set; }

        /// <summary>
        /// Match established connections. When enabled:
        ///   * Rule only applies to packets that are part of an existing connection
        ///   * Useful for allowing return traffic without creating separate rules
        ///   * Common in WAN_IN rules to allow responses to outbound connections
        /// 
        /// Example: Allow established connections from WAN while blocking new incoming connections
        /// </summary>
        [Input("stateEstablished")]
        public Input<bool>? StateEstablished { get; set; }

        /// <summary>
        /// Match where the state is invalid.
        /// </summary>
        [Input("stateInvalid")]
        public Input<bool>? StateInvalid { get; set; }

        /// <summary>
        /// Match where the state is new.
        /// </summary>
        [Input("stateNew")]
        public Input<bool>? StateNew { get; set; }

        /// <summary>
        /// Match where the state is related.
        /// </summary>
        [Input("stateRelated")]
        public Input<bool>? StateRelated { get; set; }

        public RuleArgs()
        {
        }
        public static new RuleArgs Empty => new RuleArgs();
    }

    public sealed class RuleState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The action to take when traffic matches this rule. Valid values are:
        ///   * `Accept` - Allow the traffic
        ///   * `Drop` - Silently block the traffic
        ///   * `Reject` - Block the traffic and send an ICMP rejection message
        /// </summary>
        [Input("action")]
        public Input<string>? Action { get; set; }

        /// <summary>
        /// The destination IPv4 address or network in CIDR notation (e.g., '192.168.1.10' or '192.168.0.0/24'). The format must match DstNetworkType - use a single IP for ADDRv4 or CIDR for NETv4.
        /// </summary>
        [Input("dstAddress")]
        public Input<string>? DstAddress { get; set; }

        /// <summary>
        /// The destination IPv6 address or network in CIDR notation (e.g., '2001:db8::1' or '2001:db8::/64'). Used for IPv6 firewall rules.
        /// </summary>
        [Input("dstAddressIpv6")]
        public Input<string>? DstAddressIpv6 { get; set; }

        [Input("dstFirewallGroupIds")]
        private InputList<string>? _dstFirewallGroupIds;

        /// <summary>
        /// A list of firewall group IDs to use as destinations. Groups can contain IP addresses, networks, or port numbers. This allows you to create reusable sets of addresses/ports and reference them in multiple rules.
        /// </summary>
        public InputList<string> DstFirewallGroupIds
        {
            get => _dstFirewallGroupIds ?? (_dstFirewallGroupIds = new InputList<string>());
            set => _dstFirewallGroupIds = value;
        }

        /// <summary>
        /// The ID of the destination network this rule applies to. This can be found in the URL when viewing the network in the UniFi controller.
        /// </summary>
        [Input("dstNetworkId")]
        public Input<string>? DstNetworkId { get; set; }

        /// <summary>
        /// The type of destination network address. Valid values are:
        ///   * `ADDRv4` - Single IPv4 address
        ///   * `NETv4` - IPv4 network in CIDR notation
        /// </summary>
        [Input("dstNetworkType")]
        public Input<string>? DstNetworkType { get; set; }

        /// <summary>
        /// The destination port(s) for this rule. Can be:
        ///   * A single port number (e.g., '80')
        ///   * A port range (e.g., '8000:8080')
        ///   * A list of ports/ranges separated by commas
        /// </summary>
        [Input("dstPort")]
        public Input<string>? DstPort { get; set; }

        /// <summary>
        /// Whether this firewall rule is active (true) or disabled (false). Defaults to true.
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        /// <summary>
        /// The ICMP type name when protocol is set to 'icmp'. Common values include:
        ///   * `echo-request` - ICMP ping requests
        ///   * `echo-reply` - ICMP ping replies
        ///   * `destination-unreachable` - Host/network unreachable messages
        ///   * `time-exceeded` - TTL exceeded messages (traceroute)
        /// </summary>
        [Input("icmpTypename")]
        public Input<string>? IcmpTypename { get; set; }

        /// <summary>
        /// The ICMPv6 type name when ProtocolV6 is set to 'ipv6-icmp'. Common values (not all are listed) include:
        ///   * `echo-request` - IPv6 ping requests
        ///   * `echo-reply` - IPv6 ping replies
        ///   * `neighbor-solicitation` - IPv6 neighbor discovery
        ///   * `neighbor-advertisement` - IPv6 neighbor announcements
        ///   * `destination-unreachable` - Host/network unreachable messages
        ///   * `packet-too-big` - Path MTU discovery messages
        /// </summary>
        [Input("icmpV6Typename")]
        public Input<string>? IcmpV6Typename { get; set; }

        /// <summary>
        /// Specify whether the rule matches on IPsec packets. Can be one of `match-ipsec` or `match-none`.
        /// </summary>
        [Input("ipSec")]
        public Input<string>? IpSec { get; set; }

        /// <summary>
        /// Enable logging for the firewall rule.
        /// </summary>
        [Input("logging")]
        public Input<bool>? Logging { get; set; }

        /// <summary>
        /// A friendly name for the firewall rule. This helps identify the rule's purpose in the UniFi controller UI.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The IPv4 protocol this rule applies to. Common values (not all are listed) include:
        ///   * `All` - Match all protocols
        ///   * `Tcp` - TCP traffic only (e.g., web, email)
        ///   * `Udp` - UDP traffic only (e.g., DNS, VoIP)
        ///   * `TcpUdp` - Both TCP and UDP
        ///   * `Icmp` - ICMP traffic (ping, traceroute)
        ///   * Protocol numbers (1-255) for other protocols
        /// 
        /// Examples:
        ///   * Use 'tcp' for web server rules (ports 80, 443)
        ///   * Use 'udp' for VoIP or gaming traffic
        ///   * Use 'all' for general network access rules
        /// </summary>
        [Input("protocol")]
        public Input<string>? Protocol { get; set; }

        /// <summary>
        /// The IPv6 protocol this rule applies to. Similar to 'protocol' but for IPv6 traffic. Common values (not all are listed) include:
        ///   * `All` - Match all protocols
        ///   * `Tcp` - TCP traffic only
        ///   * `Udp` - UDP traffic only
        ///   * `TcpUdp` - Both TCP and UDP traffic
        ///   * `ipv6-icmp` - ICMPv6 traffic
        /// </summary>
        [Input("protocolV6")]
        public Input<string>? ProtocolV6 { get; set; }

        /// <summary>
        /// The processing order for this rule. Lower numbers are processed first. Custom rules should use:
        ///   * 2000-2999 for rules processed before auto-generated rules
        ///   * 4000-4999 for rules processed after auto-generated rules
        /// </summary>
        [Input("ruleIndex")]
        public Input<int>? RuleIndex { get; set; }

        /// <summary>
        /// Defines which traffic flow this rule applies to. The format is [NETWORK]_[DIRECTION], where:
        ///   * NETWORK can be: WAN, LAN, GUEST (or their IPv6 variants WANv6, LANv6, GUESTv6)
        ///   * DIRECTION can be:
        ///     * IN - Traffic entering the network
        ///     * OUT - Traffic leaving the network
        ///     * LOCAL - Traffic destined for the USG/UDM itself
        /// 
        /// Examples: WAN_IN (incoming WAN traffic), LAN_OUT (outgoing LAN traffic), GUEST_LOCAL (traffic to Controller from guest network)
        /// </summary>
        [Input("ruleset")]
        public Input<string>? Ruleset { get; set; }

        /// <summary>
        /// The name of the UniFi site where the firewall rule should be created. If not specified, the default site will be used.
        /// </summary>
        [Input("site")]
        public Input<string>? Site { get; set; }

        /// <summary>
        /// The source IPv4 address for the firewall rule.
        /// </summary>
        [Input("srcAddress")]
        public Input<string>? SrcAddress { get; set; }

        /// <summary>
        /// The source IPv6 address or network in CIDR notation (e.g., '2001:db8::1' or '2001:db8::/64'). Used for IPv6 firewall rules.
        /// </summary>
        [Input("srcAddressIpv6")]
        public Input<string>? SrcAddressIpv6 { get; set; }

        [Input("srcFirewallGroupIds")]
        private InputList<string>? _srcFirewallGroupIds;

        /// <summary>
        /// A list of firewall group IDs to use as sources. Groups can contain:
        ///   * IP Address Groups - For matching specific IP addresses
        ///   * Network Groups - For matching entire subnets
        ///   * Port Groups - For matching specific port numbers
        /// 
        /// Example uses:
        ///   * Group of trusted admin IPs for remote access
        ///   * Group of IoT device networks for isolation
        ///   * Group of common service ports for allowing specific applications
        /// </summary>
        public InputList<string> SrcFirewallGroupIds
        {
            get => _srcFirewallGroupIds ?? (_srcFirewallGroupIds = new InputList<string>());
            set => _srcFirewallGroupIds = value;
        }

        /// <summary>
        /// The source MAC address this rule applies to. Use this to create rules that match specific devices regardless of their IP address. Format: 'XX:XX:XX:XX:XX:XX'. MAC addresses are case-insensitive.
        /// </summary>
        [Input("srcMac")]
        public Input<string>? SrcMac { get; set; }

        /// <summary>
        /// The ID of the source network this rule applies to. This can be found in the URL when viewing the network in the UniFi controller, or by using the network's name in the form `[site]/[NetworkName]`.
        /// </summary>
        [Input("srcNetworkId")]
        public Input<string>? SrcNetworkId { get; set; }

        /// <summary>
        /// The type of source network address. Valid values are:
        ///   * `ADDRv4` - Single IPv4 address
        ///   * `NETv4` - IPv4 network in CIDR notation
        /// </summary>
        [Input("srcNetworkType")]
        public Input<string>? SrcNetworkType { get; set; }

        /// <summary>
        /// The source port(s) for this rule. Can be:
        ///   * A single port number (e.g., '80')
        ///   * A port range (e.g., '8000:8080')
        ///   * A list of ports/ranges separated by commas
        /// </summary>
        [Input("srcPort")]
        public Input<string>? SrcPort { get; set; }

        /// <summary>
        /// Match established connections. When enabled:
        ///   * Rule only applies to packets that are part of an existing connection
        ///   * Useful for allowing return traffic without creating separate rules
        ///   * Common in WAN_IN rules to allow responses to outbound connections
        /// 
        /// Example: Allow established connections from WAN while blocking new incoming connections
        /// </summary>
        [Input("stateEstablished")]
        public Input<bool>? StateEstablished { get; set; }

        /// <summary>
        /// Match where the state is invalid.
        /// </summary>
        [Input("stateInvalid")]
        public Input<bool>? StateInvalid { get; set; }

        /// <summary>
        /// Match where the state is new.
        /// </summary>
        [Input("stateNew")]
        public Input<bool>? StateNew { get; set; }

        /// <summary>
        /// Match where the state is related.
        /// </summary>
        [Input("stateRelated")]
        public Input<bool>? StateRelated { get; set; }

        public RuleState()
        {
        }
        public static new RuleState Empty => new RuleState();
    }
}
