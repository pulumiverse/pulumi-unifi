// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace Pulumiverse.Unifi.Firewall
{
    /// <summary>
    /// The `unifi.firewall.ZonePolicy` resource manages firewall policies between zones in the UniFi controller. This resource allows you to create, update, and delete policies that define allowed or blocked traffic between zones.
    /// 
    /// !&gt; This is experimental feature, that requires UniFi OS 9.0.0 or later and Zone Based Firewall feature enabled. Check [official documentation](https://help.ui.com/hc/en-us/articles/28223082254743-Migrating-to-Zone-Based-Firewalls-in-UniFi) how to migate to Zone-Based firewalls.
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Unifi = Pulumiverse.Unifi;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var network = new Unifi.Network("network", new()
    ///     {
    ///         Name = "my-network",
    ///         Purpose = "corporate",
    ///         Subnet = "10.0.10.0/24",
    ///         VlanId = 400,
    ///     });
    /// 
    ///     var src = new Unifi.Firewall.Zone("src", new()
    ///     {
    ///         Name = "my-source-zone",
    ///         Networks = new[]
    ///         {
    ///             network.Id,
    ///         },
    ///     });
    /// 
    ///     var dst = new Unifi.Firewall.Zone("dst", new()
    ///     {
    ///         Name = "my-destination-zone",
    ///     });
    /// 
    ///     // Allow TCP/UDP traffic from any ip and port other than 192.168.1.1 and 443 in `src` zone to `dst` zone
    ///     var policy = new Unifi.Firewall.ZonePolicy("policy", new()
    ///     {
    ///         Name = "my-zone-policy",
    ///         Action = "ALLOW",
    ///         Protocol = "tcp_udp",
    ///         Source = new Unifi.Firewall.Inputs.ZonePolicySourceArgs
    ///         {
    ///             ZoneId = src.Id,
    ///             Ips = new[]
    ///             {
    ///                 "192.168.1.1",
    ///             },
    ///             Port = 443,
    ///             MatchOppositeIps = true,
    ///             MatchOppositePorts = true,
    ///         },
    ///         Destination = new Unifi.Firewall.Inputs.ZonePolicyDestinationArgs
    ///         {
    ///             ZoneId = dst.Id,
    ///         },
    ///         Schedule = new Unifi.Firewall.Inputs.ZonePolicyScheduleArgs
    ///         {
    ///             Mode = "EVERY_DAY",
    ///             TimeAllDay = false,
    ///             TimeFrom = "08:00",
    ///             TimeTo = "17:00",
    ///         },
    ///     });
    /// 
    ///     var web_ports = new Unifi.Firewall.Group("web-ports", new()
    ///     {
    ///         Name = "web-apps",
    ///         Type = "port-group",
    ///         Members = new[]
    ///         {
    ///             "80",
    ///             "443",
    ///         },
    ///     });
    /// 
    ///     // Block TCP/UDP traffic from any ip and port in `src` zone to `dst` zone ports 80 and 443 defined in port group
    ///     var policy2 = new Unifi.Firewall.ZonePolicy("policy2", new()
    ///     {
    ///         Name = "my-policy-2",
    ///         Action = "BLOCK",
    ///         Protocol = "tcp_udp",
    ///         Source = new Unifi.Firewall.Inputs.ZonePolicySourceArgs
    ///         {
    ///             ZoneId = src.Id,
    ///         },
    ///         Destination = new Unifi.Firewall.Inputs.ZonePolicyDestinationArgs
    ///         {
    ///             ZoneId = dst.Id,
    ///             PortGroupId = web_ports.Id,
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// import from provider configured site
    /// 
    /// ```sh
    /// $ pulumi import unifi:firewall/zonePolicy:ZonePolicy mynetwork 5dc28e5e9106d105bdc87217
    /// ```
    /// 
    /// import from another site
    /// 
    /// ```sh
    /// $ pulumi import unifi:firewall/zonePolicy:ZonePolicy mynetwork zone:5dc28e5e9106d105bdc87217
    /// ```
    /// </summary>
    [UnifiResourceType("unifi:firewall/zonePolicy:ZonePolicy")]
    public partial class ZonePolicy : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Determines which action to take on matching traffic. Must be one of `BLOCK`, `ALLOW`, or `REJECT`.
        /// </summary>
        [Output("action")]
        public Output<string> Action { get; private set; } = null!;

        /// <summary>
        /// Creates a built-in policy for the opposite Zone Pair to automatically allow the return traffic. If disabled, return traffic must be manually allowed
        /// </summary>
        [Output("autoAllowReturnTraffic")]
        public Output<bool> AutoAllowReturnTraffic { get; private set; } = null!;

        /// <summary>
        /// Optionally match on a firewall connection state such as traffic associated with an already existing connection. Valid values are `ALL`, `RESPOND_ONLY`, or `CUSTOM`.
        /// </summary>
        [Output("connectionStateType")]
        public Output<string> ConnectionStateType { get; private set; } = null!;

        /// <summary>
        /// Connection states to match when `ConnectionStateType` is `CUSTOM`. Valid values include `ESTABLISHED`, `NEW`, `RELATED`, and `INVALID`.
        /// </summary>
        [Output("connectionStates")]
        public Output<ImmutableArray<string>> ConnectionStates { get; private set; } = null!;

        /// <summary>
        /// Description of the firewall zone policy.
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// The zone matching the destination of the traffic. Optionally match on a specific destination inside the zone.
        /// </summary>
        [Output("destination")]
        public Output<Outputs.ZonePolicyDestination> Destination { get; private set; } = null!;

        /// <summary>
        /// Enable the policy
        /// </summary>
        [Output("enabled")]
        public Output<bool> Enabled { get; private set; } = null!;

        /// <summary>
        /// Priority index for the policy.
        /// </summary>
        [Output("index")]
        public Output<int> Index { get; private set; } = null!;

        /// <summary>
        /// Optionally match on only IPv4 or IPv6. Valid values are `BOTH`, `IPV4`, or `IPV6`.
        /// </summary>
        [Output("ipVersion")]
        public Output<string> IpVersion { get; private set; } = null!;

        /// <summary>
        /// Enable to generate syslog entries when traffic is matched.
        /// </summary>
        [Output("logging")]
        public Output<bool> Logging { get; private set; } = null!;

        /// <summary>
        /// Optionally match on traffic encrypted by IPsec. This is typically used for Ipsec Policy-Based VPNs. Valid values are `MATCH_IP_SEC` or `MATCH_NON_IP_SEC`.
        /// </summary>
        [Output("matchIpSecType")]
        public Output<string?> MatchIpSecType { get; private set; } = null!;

        /// <summary>
        /// Whether to match the opposite protocol.
        /// </summary>
        [Output("matchOppositeProtocol")]
        public Output<bool> MatchOppositeProtocol { get; private set; } = null!;

        /// <summary>
        /// The name of the firewall zone policy.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Optionally match a specific protocol. Valid values include: `All`, `TcpUdp`, `Tcp`, `Udp`, etc.
        /// </summary>
        [Output("protocol")]
        public Output<string> Protocol { get; private set; } = null!;

        /// <summary>
        /// Enforce this policy at specific times.
        /// </summary>
        [Output("schedule")]
        public Output<Outputs.ZonePolicySchedule> Schedule { get; private set; } = null!;

        /// <summary>
        /// The name of the UniFi site where this resource should be applied. If not specified, the default site will be used.
        /// </summary>
        [Output("site")]
        public Output<string> Site { get; private set; } = null!;

        /// <summary>
        /// The zone matching the source of the traffic. Optionally match on a specific source inside the zone.
        /// </summary>
        [Output("source")]
        public Output<Outputs.ZonePolicySource> Source { get; private set; } = null!;


        /// <summary>
        /// Create a ZonePolicy resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public ZonePolicy(string name, ZonePolicyArgs args, CustomResourceOptions? options = null)
            : base("unifi:firewall/zonePolicy:ZonePolicy", name, args ?? new ZonePolicyArgs(), MakeResourceOptions(options, ""))
        {
        }

        private ZonePolicy(string name, Input<string> id, ZonePolicyState? state = null, CustomResourceOptions? options = null)
            : base("unifi:firewall/zonePolicy:ZonePolicy", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "github://api.github.com/pulumiverse",
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing ZonePolicy resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static ZonePolicy Get(string name, Input<string> id, ZonePolicyState? state = null, CustomResourceOptions? options = null)
        {
            return new ZonePolicy(name, id, state, options);
        }
    }

    public sealed class ZonePolicyArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Determines which action to take on matching traffic. Must be one of `BLOCK`, `ALLOW`, or `REJECT`.
        /// </summary>
        [Input("action", required: true)]
        public Input<string> Action { get; set; } = null!;

        /// <summary>
        /// Creates a built-in policy for the opposite Zone Pair to automatically allow the return traffic. If disabled, return traffic must be manually allowed
        /// </summary>
        [Input("autoAllowReturnTraffic")]
        public Input<bool>? AutoAllowReturnTraffic { get; set; }

        /// <summary>
        /// Optionally match on a firewall connection state such as traffic associated with an already existing connection. Valid values are `ALL`, `RESPOND_ONLY`, or `CUSTOM`.
        /// </summary>
        [Input("connectionStateType")]
        public Input<string>? ConnectionStateType { get; set; }

        [Input("connectionStates")]
        private InputList<string>? _connectionStates;

        /// <summary>
        /// Connection states to match when `ConnectionStateType` is `CUSTOM`. Valid values include `ESTABLISHED`, `NEW`, `RELATED`, and `INVALID`.
        /// </summary>
        public InputList<string> ConnectionStates
        {
            get => _connectionStates ?? (_connectionStates = new InputList<string>());
            set => _connectionStates = value;
        }

        /// <summary>
        /// Description of the firewall zone policy.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// The zone matching the destination of the traffic. Optionally match on a specific destination inside the zone.
        /// </summary>
        [Input("destination", required: true)]
        public Input<Inputs.ZonePolicyDestinationArgs> Destination { get; set; } = null!;

        /// <summary>
        /// Enable the policy
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        /// <summary>
        /// Priority index for the policy.
        /// </summary>
        [Input("index")]
        public Input<int>? Index { get; set; }

        /// <summary>
        /// Optionally match on only IPv4 or IPv6. Valid values are `BOTH`, `IPV4`, or `IPV6`.
        /// </summary>
        [Input("ipVersion")]
        public Input<string>? IpVersion { get; set; }

        /// <summary>
        /// Enable to generate syslog entries when traffic is matched.
        /// </summary>
        [Input("logging")]
        public Input<bool>? Logging { get; set; }

        /// <summary>
        /// Optionally match on traffic encrypted by IPsec. This is typically used for Ipsec Policy-Based VPNs. Valid values are `MATCH_IP_SEC` or `MATCH_NON_IP_SEC`.
        /// </summary>
        [Input("matchIpSecType")]
        public Input<string>? MatchIpSecType { get; set; }

        /// <summary>
        /// Whether to match the opposite protocol.
        /// </summary>
        [Input("matchOppositeProtocol")]
        public Input<bool>? MatchOppositeProtocol { get; set; }

        /// <summary>
        /// The name of the firewall zone policy.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Optionally match a specific protocol. Valid values include: `All`, `TcpUdp`, `Tcp`, `Udp`, etc.
        /// </summary>
        [Input("protocol")]
        public Input<string>? Protocol { get; set; }

        /// <summary>
        /// Enforce this policy at specific times.
        /// </summary>
        [Input("schedule")]
        public Input<Inputs.ZonePolicyScheduleArgs>? Schedule { get; set; }

        /// <summary>
        /// The name of the UniFi site where this resource should be applied. If not specified, the default site will be used.
        /// </summary>
        [Input("site")]
        public Input<string>? Site { get; set; }

        /// <summary>
        /// The zone matching the source of the traffic. Optionally match on a specific source inside the zone.
        /// </summary>
        [Input("source", required: true)]
        public Input<Inputs.ZonePolicySourceArgs> Source { get; set; } = null!;

        public ZonePolicyArgs()
        {
        }
        public static new ZonePolicyArgs Empty => new ZonePolicyArgs();
    }

    public sealed class ZonePolicyState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Determines which action to take on matching traffic. Must be one of `BLOCK`, `ALLOW`, or `REJECT`.
        /// </summary>
        [Input("action")]
        public Input<string>? Action { get; set; }

        /// <summary>
        /// Creates a built-in policy for the opposite Zone Pair to automatically allow the return traffic. If disabled, return traffic must be manually allowed
        /// </summary>
        [Input("autoAllowReturnTraffic")]
        public Input<bool>? AutoAllowReturnTraffic { get; set; }

        /// <summary>
        /// Optionally match on a firewall connection state such as traffic associated with an already existing connection. Valid values are `ALL`, `RESPOND_ONLY`, or `CUSTOM`.
        /// </summary>
        [Input("connectionStateType")]
        public Input<string>? ConnectionStateType { get; set; }

        [Input("connectionStates")]
        private InputList<string>? _connectionStates;

        /// <summary>
        /// Connection states to match when `ConnectionStateType` is `CUSTOM`. Valid values include `ESTABLISHED`, `NEW`, `RELATED`, and `INVALID`.
        /// </summary>
        public InputList<string> ConnectionStates
        {
            get => _connectionStates ?? (_connectionStates = new InputList<string>());
            set => _connectionStates = value;
        }

        /// <summary>
        /// Description of the firewall zone policy.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// The zone matching the destination of the traffic. Optionally match on a specific destination inside the zone.
        /// </summary>
        [Input("destination")]
        public Input<Inputs.ZonePolicyDestinationGetArgs>? Destination { get; set; }

        /// <summary>
        /// Enable the policy
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        /// <summary>
        /// Priority index for the policy.
        /// </summary>
        [Input("index")]
        public Input<int>? Index { get; set; }

        /// <summary>
        /// Optionally match on only IPv4 or IPv6. Valid values are `BOTH`, `IPV4`, or `IPV6`.
        /// </summary>
        [Input("ipVersion")]
        public Input<string>? IpVersion { get; set; }

        /// <summary>
        /// Enable to generate syslog entries when traffic is matched.
        /// </summary>
        [Input("logging")]
        public Input<bool>? Logging { get; set; }

        /// <summary>
        /// Optionally match on traffic encrypted by IPsec. This is typically used for Ipsec Policy-Based VPNs. Valid values are `MATCH_IP_SEC` or `MATCH_NON_IP_SEC`.
        /// </summary>
        [Input("matchIpSecType")]
        public Input<string>? MatchIpSecType { get; set; }

        /// <summary>
        /// Whether to match the opposite protocol.
        /// </summary>
        [Input("matchOppositeProtocol")]
        public Input<bool>? MatchOppositeProtocol { get; set; }

        /// <summary>
        /// The name of the firewall zone policy.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Optionally match a specific protocol. Valid values include: `All`, `TcpUdp`, `Tcp`, `Udp`, etc.
        /// </summary>
        [Input("protocol")]
        public Input<string>? Protocol { get; set; }

        /// <summary>
        /// Enforce this policy at specific times.
        /// </summary>
        [Input("schedule")]
        public Input<Inputs.ZonePolicyScheduleGetArgs>? Schedule { get; set; }

        /// <summary>
        /// The name of the UniFi site where this resource should be applied. If not specified, the default site will be used.
        /// </summary>
        [Input("site")]
        public Input<string>? Site { get; set; }

        /// <summary>
        /// The zone matching the source of the traffic. Optionally match on a specific source inside the zone.
        /// </summary>
        [Input("source")]
        public Input<Inputs.ZonePolicySourceGetArgs>? Source { get; set; }

        public ZonePolicyState()
        {
        }
        public static new ZonePolicyState Empty => new ZonePolicyState();
    }
}
