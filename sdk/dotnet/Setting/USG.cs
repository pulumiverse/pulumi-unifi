// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace Pulumiverse.Unifi.Setting
{
    /// <summary>
    /// The `unifi.setting.USG` resource manages advanced settings for UniFi Security Gateways (USG) and UniFi Dream Machines (UDM/UDM-Pro).
    /// 
    /// This resource allows you to configure gateway-specific features including:
    ///   * Multicast DNS (mDNS) for cross-VLAN service discovery
    ///   * DHCP relay for forwarding DHCP requests to external servers
    ///   * Geo IP filtering for country-based traffic control
    ///   * UPNP/NAT-PMP for automatic port forwarding
    ///   * Protocol helpers for FTP, GRE, H323, PPTP, SIP, and TFTP
    ///   * TCP/UDP timeout settings for connection tracking
    ///   * Security features like SYN cookies and ICMP redirect controls
    ///   * MSS clamping for optimizing MTU issues
    /// 
    /// Note: Some settings may not be available on all controller versions. For example, MulticastDnsEnabled is not supported on UniFi OS v7+. Changes to certain attributes may not be reflected in the plan unless explicitly modified in the configuration.
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Unifi = Pulumiverse.Unifi;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var example = new Unifi.Setting.USG("example", new()
    ///     {
    ///         GeoIpFiltering = new Unifi.Setting.Inputs.USGGeoIpFilteringArgs
    ///         {
    ///             Block = "block",
    ///             Countries = new[]
    ///             {
    ///                 "UK",
    ///                 "CN",
    ///                 "AU",
    ///             },
    ///             TrafficDirection = "both",
    ///         },
    ///         Upnp = new Unifi.Setting.Inputs.USGUpnpArgs
    ///         {
    ///             NatPmpEnabled = true,
    ///             SecureMode = true,
    ///             WanInterface = "WAN",
    ///         },
    ///         DnsVerification = new Unifi.Setting.Inputs.USGDnsVerificationArgs
    ///         {
    ///             Domain = "example.com",
    ///             PrimaryDnsServer = "1.1.1.1",
    ///             SecondaryDnsServer = "1.0.0.1",
    ///             SettingPreference = "manual",
    ///         },
    ///         TcpTimeouts = new Unifi.Setting.Inputs.USGTcpTimeoutsArgs
    ///         {
    ///             CloseTimeout = 10,
    ///             EstablishedTimeout = 3600,
    ///             CloseWaitTimeout = 20,
    ///             FinWaitTimeout = 30,
    ///             LastAckTimeout = 30,
    ///             SynRecvTimeout = 60,
    ///             SynSentTimeout = 120,
    ///             TimeWaitTimeout = 120,
    ///         },
    ///         ArpCacheTimeout = "custom",
    ///         ArpCacheBaseReachable = 60,
    ///         BroadcastPing = true,
    ///         DhcpdHostfileUpdate = true,
    ///         DhcpdUseDnsmasq = true,
    ///         DnsmasqAllServers = true,
    ///         DhcpRelay = new Unifi.Setting.Inputs.USGDhcpRelayArgs
    ///         {
    ///             AgentsPackets = "forward",
    ///             HopCount = 5,
    ///         },
    ///         DhcpRelayServers = new[]
    ///         {
    ///             "10.1.2.3",
    ///             "10.1.2.4",
    ///         },
    ///         EchoServer = "echo.example.com",
    ///         FtpModule = true,
    ///         GreModule = true,
    ///         TftpModule = true,
    ///         IcmpTimeout = 20,
    ///         LldpEnableAll = true,
    ///         MssClamp = "auto",
    ///         MssClampMss = 1452,
    ///         OffloadAccounting = true,
    ///         OffloadL2Blocking = true,
    ///         OffloadScheduling = false,
    ///         OtherTimeout = 600,
    ///         TimeoutSettingPreference = "auto",
    ///         ReceiveRedirects = false,
    ///         SendRedirects = true,
    ///         SynCookies = true,
    ///         UdpOtherTimeout = 30,
    ///         UdpStreamTimeout = 120,
    ///     });
    /// 
    /// });
    /// ```
    /// </summary>
    [UnifiResourceType("unifi:setting/uSG:USG")]
    public partial class USG : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The base reachable timeout (in seconds) for ARP cache entries. This controls how long the gateway considers a MAC-to-IP mapping valid without needing to refresh it. Higher values reduce network traffic but may cause stale entries if devices change IP addresses frequently.
        /// </summary>
        [Output("arpCacheBaseReachable")]
        public Output<int> ArpCacheBaseReachable { get; private set; } = null!;

        /// <summary>
        /// The timeout strategy for ARP cache entries. Valid values are:
        ///   * `Normal` - Use system default timeouts
        ///   * `min-dhcp-lease` - Set ARP timeout to match the minimum DHCP lease time
        ///   * `Custom` - Use the custom timeout value specified in `ArpCacheBaseReachable`
        /// 
        /// This setting determines how long MAC-to-IP mappings are stored in the ARP cache before being refreshed.
        /// </summary>
        [Output("arpCacheTimeout")]
        public Output<string> ArpCacheTimeout { get; private set; } = null!;

        /// <summary>
        /// Enable responding to broadcast ping requests (ICMP echo requests sent to the broadcast address). When enabled, the gateway will respond to pings sent to the broadcast address of the network (e.g., 192.168.1.255). This can be useful for network diagnostics but may also be used in certain denial-of-service attacks.
        /// </summary>
        [Output("broadcastPing")]
        public Output<bool> BroadcastPing { get; private set; } = null!;

        /// <summary>
        /// Advanced DHCP relay configuration settings. Controls how the gateway forwards DHCP requests to external servers and manages DHCP relay agent behavior. Use this block to fine-tune DHCP relay functionality beyond simply specifying relay servers.
        /// </summary>
        [Output("dhcpRelay")]
        public Output<Outputs.USGDhcpRelay> DhcpRelay { get; private set; } = null!;

        /// <summary>
        /// List of up to 5 DHCP relay servers (specified by IP address) that will receive forwarded DHCP requests. This is useful when you want to use external DHCP servers instead of the built-in DHCP server on the USG/UDM. When configured, the gateway will forward DHCP discovery packets from clients to these external servers, allowing centralized IP address management across multiple networks. Example: `['192.168.1.5', '192.168.2.5']`
        /// </summary>
        [Output("dhcpRelayServers")]
        public Output<ImmutableArray<string>> DhcpRelayServers { get; private set; } = null!;

        /// <summary>
        /// Enable updating the gateway's host files with DHCP client information. When enabled, the gateway will automatically add entries to its host file for each DHCP client, allowing hostname resolution for devices that receive IP addresses via DHCP. This improves name resolution on the local network.
        /// </summary>
        [Output("dhcpdHostfileUpdate")]
        public Output<bool> DhcpdHostfileUpdate { get; private set; } = null!;

        /// <summary>
        /// Use dnsmasq for DHCP services instead of the default DHCP server. Dnsmasq provides integrated DNS and DHCP functionality with additional features like DNS caching, DHCP static leases, and local domain name resolution. This can improve DNS resolution performance and provide more flexible DHCP options.
        /// </summary>
        [Output("dhcpdUseDnsmasq")]
        public Output<bool> DhcpdUseDnsmasq { get; private set; } = null!;

        /// <summary>
        /// DNS verification settings for validating DNS responses. This feature helps detect and prevent DNS spoofing attacks by verifying DNS responses against trusted DNS servers. When configured, the gateway can compare DNS responses with those from known trusted servers to identify potential tampering or poisoning attempts. Requires controller version 8.5 or later.
        /// </summary>
        [Output("dnsVerification")]
        public Output<Outputs.USGDnsVerification> DnsVerification { get; private set; } = null!;

        /// <summary>
        /// When enabled, dnsmasq will query all configured DNS servers simultaneously and use the fastest response. This can improve DNS resolution speed but may increase DNS traffic. By default, dnsmasq queries servers sequentially, only trying the next server if the current one fails to respond.
        /// </summary>
        [Output("dnsmasqAllServers")]
        public Output<bool> DnsmasqAllServers { get; private set; } = null!;

        /// <summary>
        /// The hostname or IP address of a server to use for network echo tests. Echo tests send packets to this server and measure response times to evaluate network connectivity and performance. This can be used for network diagnostics and monitoring.
        /// </summary>
        [Output("echoServer")]
        public Output<string> EchoServer { get; private set; } = null!;

        /// <summary>
        /// Enable the FTP (File Transfer Protocol) helper module. This module allows the gateway to properly handle FTP connections through NAT by tracking the control channel and dynamically opening required data ports. Without this helper, passive FTP connections may fail when clients are behind NAT.
        /// </summary>
        [Output("ftpModule")]
        public Output<bool> FtpModule { get; private set; } = null!;

        /// <summary>
        /// Geographic IP filtering configuration that allows blocking or allowing traffic based on country of origin. This feature uses IP geolocation databases to identify the country associated with IP addresses and apply filtering rules. Useful for implementing country-specific access policies or blocking traffic from high-risk regions. Requires controller version 7.0 or later.
        /// </summary>
        [Output("geoIpFiltering")]
        public Output<Outputs.USGGeoIpFiltering?> GeoIpFiltering { get; private set; } = null!;

        /// <summary>
        /// Whether Geo IP Filtering is enabled. When enabled, the gateway will apply the specified country-based
        /// </summary>
        [Output("geoIpFilteringEnabled")]
        public Output<bool> GeoIpFilteringEnabled { get; private set; } = null!;

        /// <summary>
        /// Enable the GRE (Generic Routing Encapsulation) protocol helper module. This module allows proper handling of GRE tunneling protocol through the gateway's firewall. GRE is commonly used for VPN tunnels and other encapsulation needs. Required if you plan to use PPTP VPNs (see `PptpModule`).
        /// </summary>
        [Output("greModule")]
        public Output<bool> GreModule { get; private set; } = null!;

        /// <summary>
        /// Enable the H.323 protocol helper module. H.323 is a standard for multimedia communications (audio, video, and data) over packet-based networks. This helper allows H.323-based applications like video conferencing systems to work properly through NAT by tracking connection details and opening required ports.
        /// </summary>
        [Output("h323Module")]
        public Output<bool> H323Module { get; private set; } = null!;

        /// <summary>
        /// ICMP timeout in seconds for connection tracking. This controls how long the gateway maintains state information for ICMP (ping) packets in its connection tracking table. Higher values maintain ICMP connection state longer, while lower values reclaim resources more quickly but may affect some diagnostic tools.
        /// </summary>
        [Output("icmpTimeout")]
        public Output<int> IcmpTimeout { get; private set; } = null!;

        /// <summary>
        /// Enable Link Layer Discovery Protocol (LLDP) on all interfaces. LLDP is a vendor-neutral protocol that allows network devices to advertise their identity, capabilities, and neighbors on a local network. When enabled, the gateway will both send and receive LLDP packets, facilitating network discovery and management tools.
        /// </summary>
        [Output("lldpEnableAll")]
        public Output<bool> LldpEnableAll { get; private set; } = null!;

        /// <summary>
        /// TCP Maximum Segment Size (MSS) clamping mode. MSS clamping adjusts the maximum segment size of TCP packets to prevent fragmentation issues when packets traverse networks with different MTU sizes. Valid values include:
        ///   * `Auto` - Automatically determine appropriate MSS values based on interface MTUs
        ///   * `Custom` - Use the custom MSS value specified in `MssClampMss`
        ///   * `Disabled` - Do not perform MSS clamping
        /// 
        /// This setting is particularly important for VPN connections and networks with non-standard MTU sizes.
        /// </summary>
        [Output("mssClamp")]
        public Output<string> MssClamp { get; private set; } = null!;

        /// <summary>
        /// Custom TCP Maximum Segment Size (MSS) value in bytes. This value is used when `MssClamp` is set to `Custom`. The MSS value should typically be set to the path MTU minus 40 bytes (for IPv4) or minus 60 bytes (for IPv6) to account for TCP/IP header overhead. Valid values range from 100 to 9999, with common values being 1460 (for standard 1500 MTU) or 1400 (for VPN tunnels).
        /// </summary>
        [Output("mssClampMss")]
        public Output<int> MssClampMss { get; private set; } = null!;

        /// <summary>
        /// Enable multicast DNS (mDNS/Bonjour/Avahi) forwarding across VLANs. This allows devices to discover services (like printers, Chromecasts, Apple devices, etc.) even when they are on different networks or VLANs. When enabled, the gateway will forward mDNS packets between networks, facilitating cross-VLAN service discovery. Note: This setting is not supported on UniFi OS v7+ as it has been replaced by mDNS settings in the network configuration.
        /// </summary>
        [Output("multicastDnsEnabled")]
        public Output<bool> MulticastDnsEnabled { get; private set; } = null!;

        /// <summary>
        /// Enable hardware accounting offload. When enabled, the gateway will use hardware acceleration for traffic accounting functions, reducing CPU load and potentially improving throughput for high-traffic environments. This setting may not be supported on all hardware models.
        /// </summary>
        [Output("offloadAccounting")]
        public Output<bool> OffloadAccounting { get; private set; } = null!;

        /// <summary>
        /// Enable hardware offload for Layer 2 (L2) blocking functions. When enabled, the gateway will use hardware acceleration for blocking traffic at the data link layer (MAC address level), which can improve performance when implementing MAC-based filtering or isolation. This setting may not be supported on all hardware models.
        /// </summary>
        [Output("offloadL2Blocking")]
        public Output<bool> OffloadL2Blocking { get; private set; } = null!;

        /// <summary>
        /// Enable hardware scheduling offload. When enabled, the gateway will use hardware acceleration for packet scheduling functions, which can improve QoS (Quality of Service) performance and throughput for prioritized traffic. This setting may not be supported on all hardware models and may affect other hardware offload capabilities.
        /// </summary>
        [Output("offloadSch")]
        public Output<bool> OffloadSch { get; private set; } = null!;

        /// <summary>
        /// Timeout (in seconds) for connection tracking of protocols other than TCP, UDP, and ICMP. This controls how long the gateway maintains state information for connections using other protocols. Higher values maintain connection state longer, while lower values reclaim resources more quickly but may affect some applications using non-standard protocols.
        /// </summary>
        [Output("otherTimeout")]
        public Output<int> OtherTimeout { get; private set; } = null!;

        /// <summary>
        /// Enable the PPTP (Point-to-Point Tunneling Protocol) helper module. This module allows PPTP VPN connections to work properly through the gateway's firewall and NAT. PPTP uses GRE for tunneling, so the `GreModule` must also be enabled for PPTP to function correctly. Note that PPTP has known security vulnerabilities and more secure VPN protocols are generally recommended.
        /// </summary>
        [Output("pptpModule")]
        public Output<bool> PptpModule { get; private set; } = null!;

        /// <summary>
        /// Enable accepting ICMP redirect messages. ICMP redirects are messages sent by routers to inform hosts of better routes to specific destinations. When enabled, the gateway will update its routing table based on these messages. While useful for route optimization, this can potentially be exploited for man-in-the-middle attacks, so it's often disabled in security-sensitive environments.
        /// </summary>
        [Output("receiveRedirects")]
        public Output<bool> ReceiveRedirects { get; private set; } = null!;

        /// <summary>
        /// Enable sending ICMP redirect messages. When enabled, the gateway will send ICMP redirect messages to hosts on the local network to inform them of better routes to specific destinations. This can help optimize network traffic but is typically only needed when the gateway has multiple interfaces on the same subnet or in complex routing scenarios.
        /// </summary>
        [Output("sendRedirects")]
        public Output<bool> SendRedirects { get; private set; } = null!;

        /// <summary>
        /// Enable the SIP (Session Initiation Protocol) helper module. SIP is used for initiating, maintaining, and terminating real-time sessions for voice, video, and messaging applications (VoIP, video conferencing). This helper allows SIP-based applications to work correctly through NAT by tracking SIP connections and dynamically opening the necessary ports for media streams.
        /// </summary>
        [Output("sipModule")]
        public Output<bool> SipModule { get; private set; } = null!;

        /// <summary>
        /// The name of the UniFi site where this resource should be applied. If not specified, the default site will be used.
        /// </summary>
        [Output("site")]
        public Output<string> Site { get; private set; } = null!;

        /// <summary>
        /// Enable SYN cookies to protect against SYN flood attacks. SYN cookies are a technique that helps mitigate TCP SYN flood attacks by avoiding the need to track incomplete connections in a backlog queue. When enabled, the gateway can continue to establish legitimate connections even when under a SYN flood attack. This is a recommended security setting for internet-facing gateways.
        /// </summary>
        [Output("synCookies")]
        public Output<bool> SynCookies { get; private set; } = null!;

        /// <summary>
        /// TCP connection timeout settings for various TCP connection states. These settings control how long the gateway maintains state information for TCP connections in different states before removing them from the connection tracking table. Proper timeout values balance resource usage with connection reliability. These settings are particularly relevant when `TimeoutSettingPreference` is set to `Manual`.
        /// </summary>
        [Output("tcpTimeouts")]
        public Output<Outputs.USGTcpTimeouts> TcpTimeouts { get; private set; } = null!;

        /// <summary>
        /// Enable the TFTP (Trivial File Transfer Protocol) helper module. This module allows TFTP connections to work properly through the gateway's firewall and NAT. TFTP is commonly used for firmware updates, configuration file transfers, and network booting of devices. The helper tracks TFTP connections and ensures return traffic is properly handled.
        /// </summary>
        [Output("tftpModule")]
        public Output<bool> TftpModule { get; private set; } = null!;

        /// <summary>
        /// Determines how connection timeout values are configured. Valid values are:
        ///   * `Auto` - The gateway will automatically determine appropriate timeout values based on system defaults
        ///   * `Manual` - Use the manually specified timeout values for various connection types
        /// 
        /// When set to `Manual`, you should specify values for the various timeout settings like `TcpTimeouts`, `UdpStreamTimeout`, `UdpOtherTimeout`, `IcmpTimeout`, and `OtherTimeout`. Requires controller version 7.0 or later.
        /// </summary>
        [Output("timeoutSettingPreference")]
        public Output<string> TimeoutSettingPreference { get; private set; } = null!;

        /// <summary>
        /// Timeout (in seconds) for general UDP connections. Since UDP is connectionless, this timeout determines how long the gateway maintains state information for UDP packets that don't match the criteria for stream connections. This applies to most short-lived UDP communications like DNS queries. Lower values free resources more quickly but may affect some applications that expect longer session persistence.
        /// </summary>
        [Output("udpOtherTimeout")]
        public Output<int> UdpOtherTimeout { get; private set; } = null!;

        /// <summary>
        /// Timeout (in seconds) for UDP stream connections. This applies to UDP traffic patterns that resemble ongoing streams, such as VoIP calls, video streaming, or online gaming. The gateway identifies these based on traffic patterns and maintains state information longer than for regular UDP traffic. Higher values improve reliability for streaming applications but consume more connection tracking resources.
        /// </summary>
        [Output("udpStreamTimeout")]
        public Output<int> UdpStreamTimeout { get; private set; } = null!;

        /// <summary>
        /// Unbind WAN monitors to prevent unnecessary traffic. When enabled, the gateway will stop certain monitoring processes that periodically check WAN connectivity. This can reduce unnecessary traffic on metered connections or in environments where the monitoring traffic might trigger security alerts. However, disabling these monitors may affect the gateway's ability to detect and respond to WAN connectivity issues. Requires controller version 9.0 or later.
        /// </summary>
        [Output("unbindWanMonitors")]
        public Output<bool> UnbindWanMonitors { get; private set; } = null!;

        /// <summary>
        /// UPNP (Universal Plug and Play) configuration settings. UPNP allows compatible applications and devices to automatically configure port forwarding rules on the gateway without manual intervention. This is commonly used by gaming consoles, media servers, VoIP applications, and other network services that require incoming connections.
        /// </summary>
        [Output("upnp")]
        public Output<Outputs.USGUpnp?> Upnp { get; private set; } = null!;

        /// <summary>
        /// Whether UPNP is enabled. When enabled, the gateway will automatically forward ports for UPNP-compatible devices
        /// </summary>
        [Output("upnpEnabled")]
        public Output<bool> UpnpEnabled { get; private set; } = null!;


        /// <summary>
        /// Create a USG resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public USG(string name, USGArgs? args = null, CustomResourceOptions? options = null)
            : base("unifi:setting/uSG:USG", name, args ?? new USGArgs(), MakeResourceOptions(options, ""))
        {
        }

        private USG(string name, Input<string> id, USGState? state = null, CustomResourceOptions? options = null)
            : base("unifi:setting/uSG:USG", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "github://api.github.com/pulumiverse",
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing USG resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static USG Get(string name, Input<string> id, USGState? state = null, CustomResourceOptions? options = null)
        {
            return new USG(name, id, state, options);
        }
    }

    public sealed class USGArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The base reachable timeout (in seconds) for ARP cache entries. This controls how long the gateway considers a MAC-to-IP mapping valid without needing to refresh it. Higher values reduce network traffic but may cause stale entries if devices change IP addresses frequently.
        /// </summary>
        [Input("arpCacheBaseReachable")]
        public Input<int>? ArpCacheBaseReachable { get; set; }

        /// <summary>
        /// The timeout strategy for ARP cache entries. Valid values are:
        ///   * `Normal` - Use system default timeouts
        ///   * `min-dhcp-lease` - Set ARP timeout to match the minimum DHCP lease time
        ///   * `Custom` - Use the custom timeout value specified in `ArpCacheBaseReachable`
        /// 
        /// This setting determines how long MAC-to-IP mappings are stored in the ARP cache before being refreshed.
        /// </summary>
        [Input("arpCacheTimeout")]
        public Input<string>? ArpCacheTimeout { get; set; }

        /// <summary>
        /// Enable responding to broadcast ping requests (ICMP echo requests sent to the broadcast address). When enabled, the gateway will respond to pings sent to the broadcast address of the network (e.g., 192.168.1.255). This can be useful for network diagnostics but may also be used in certain denial-of-service attacks.
        /// </summary>
        [Input("broadcastPing")]
        public Input<bool>? BroadcastPing { get; set; }

        /// <summary>
        /// Advanced DHCP relay configuration settings. Controls how the gateway forwards DHCP requests to external servers and manages DHCP relay agent behavior. Use this block to fine-tune DHCP relay functionality beyond simply specifying relay servers.
        /// </summary>
        [Input("dhcpRelay")]
        public Input<Inputs.USGDhcpRelayArgs>? DhcpRelay { get; set; }

        [Input("dhcpRelayServers")]
        private InputList<string>? _dhcpRelayServers;

        /// <summary>
        /// List of up to 5 DHCP relay servers (specified by IP address) that will receive forwarded DHCP requests. This is useful when you want to use external DHCP servers instead of the built-in DHCP server on the USG/UDM. When configured, the gateway will forward DHCP discovery packets from clients to these external servers, allowing centralized IP address management across multiple networks. Example: `['192.168.1.5', '192.168.2.5']`
        /// </summary>
        [Obsolete(@"This attribute is deprecated and will be removed in a future release. `dhcp_relay.servers` attribute will be introduced as a replacement.")]
        public InputList<string> DhcpRelayServers
        {
            get => _dhcpRelayServers ?? (_dhcpRelayServers = new InputList<string>());
            set => _dhcpRelayServers = value;
        }

        /// <summary>
        /// Enable updating the gateway's host files with DHCP client information. When enabled, the gateway will automatically add entries to its host file for each DHCP client, allowing hostname resolution for devices that receive IP addresses via DHCP. This improves name resolution on the local network.
        /// </summary>
        [Input("dhcpdHostfileUpdate")]
        public Input<bool>? DhcpdHostfileUpdate { get; set; }

        /// <summary>
        /// Use dnsmasq for DHCP services instead of the default DHCP server. Dnsmasq provides integrated DNS and DHCP functionality with additional features like DNS caching, DHCP static leases, and local domain name resolution. This can improve DNS resolution performance and provide more flexible DHCP options.
        /// </summary>
        [Input("dhcpdUseDnsmasq")]
        public Input<bool>? DhcpdUseDnsmasq { get; set; }

        /// <summary>
        /// DNS verification settings for validating DNS responses. This feature helps detect and prevent DNS spoofing attacks by verifying DNS responses against trusted DNS servers. When configured, the gateway can compare DNS responses with those from known trusted servers to identify potential tampering or poisoning attempts. Requires controller version 8.5 or later.
        /// </summary>
        [Input("dnsVerification")]
        public Input<Inputs.USGDnsVerificationArgs>? DnsVerification { get; set; }

        /// <summary>
        /// When enabled, dnsmasq will query all configured DNS servers simultaneously and use the fastest response. This can improve DNS resolution speed but may increase DNS traffic. By default, dnsmasq queries servers sequentially, only trying the next server if the current one fails to respond.
        /// </summary>
        [Input("dnsmasqAllServers")]
        public Input<bool>? DnsmasqAllServers { get; set; }

        /// <summary>
        /// The hostname or IP address of a server to use for network echo tests. Echo tests send packets to this server and measure response times to evaluate network connectivity and performance. This can be used for network diagnostics and monitoring.
        /// </summary>
        [Input("echoServer")]
        public Input<string>? EchoServer { get; set; }

        /// <summary>
        /// Enable the FTP (File Transfer Protocol) helper module. This module allows the gateway to properly handle FTP connections through NAT by tracking the control channel and dynamically opening required data ports. Without this helper, passive FTP connections may fail when clients are behind NAT.
        /// </summary>
        [Input("ftpModule")]
        public Input<bool>? FtpModule { get; set; }

        /// <summary>
        /// Geographic IP filtering configuration that allows blocking or allowing traffic based on country of origin. This feature uses IP geolocation databases to identify the country associated with IP addresses and apply filtering rules. Useful for implementing country-specific access policies or blocking traffic from high-risk regions. Requires controller version 7.0 or later.
        /// </summary>
        [Input("geoIpFiltering")]
        public Input<Inputs.USGGeoIpFilteringArgs>? GeoIpFiltering { get; set; }

        /// <summary>
        /// Enable the GRE (Generic Routing Encapsulation) protocol helper module. This module allows proper handling of GRE tunneling protocol through the gateway's firewall. GRE is commonly used for VPN tunnels and other encapsulation needs. Required if you plan to use PPTP VPNs (see `PptpModule`).
        /// </summary>
        [Input("greModule")]
        public Input<bool>? GreModule { get; set; }

        /// <summary>
        /// Enable the H.323 protocol helper module. H.323 is a standard for multimedia communications (audio, video, and data) over packet-based networks. This helper allows H.323-based applications like video conferencing systems to work properly through NAT by tracking connection details and opening required ports.
        /// </summary>
        [Input("h323Module")]
        public Input<bool>? H323Module { get; set; }

        /// <summary>
        /// ICMP timeout in seconds for connection tracking. This controls how long the gateway maintains state information for ICMP (ping) packets in its connection tracking table. Higher values maintain ICMP connection state longer, while lower values reclaim resources more quickly but may affect some diagnostic tools.
        /// </summary>
        [Input("icmpTimeout")]
        public Input<int>? IcmpTimeout { get; set; }

        /// <summary>
        /// Enable Link Layer Discovery Protocol (LLDP) on all interfaces. LLDP is a vendor-neutral protocol that allows network devices to advertise their identity, capabilities, and neighbors on a local network. When enabled, the gateway will both send and receive LLDP packets, facilitating network discovery and management tools.
        /// </summary>
        [Input("lldpEnableAll")]
        public Input<bool>? LldpEnableAll { get; set; }

        /// <summary>
        /// TCP Maximum Segment Size (MSS) clamping mode. MSS clamping adjusts the maximum segment size of TCP packets to prevent fragmentation issues when packets traverse networks with different MTU sizes. Valid values include:
        ///   * `Auto` - Automatically determine appropriate MSS values based on interface MTUs
        ///   * `Custom` - Use the custom MSS value specified in `MssClampMss`
        ///   * `Disabled` - Do not perform MSS clamping
        /// 
        /// This setting is particularly important for VPN connections and networks with non-standard MTU sizes.
        /// </summary>
        [Input("mssClamp")]
        public Input<string>? MssClamp { get; set; }

        /// <summary>
        /// Custom TCP Maximum Segment Size (MSS) value in bytes. This value is used when `MssClamp` is set to `Custom`. The MSS value should typically be set to the path MTU minus 40 bytes (for IPv4) or minus 60 bytes (for IPv6) to account for TCP/IP header overhead. Valid values range from 100 to 9999, with common values being 1460 (for standard 1500 MTU) or 1400 (for VPN tunnels).
        /// </summary>
        [Input("mssClampMss")]
        public Input<int>? MssClampMss { get; set; }

        /// <summary>
        /// Enable multicast DNS (mDNS/Bonjour/Avahi) forwarding across VLANs. This allows devices to discover services (like printers, Chromecasts, Apple devices, etc.) even when they are on different networks or VLANs. When enabled, the gateway will forward mDNS packets between networks, facilitating cross-VLAN service discovery. Note: This setting is not supported on UniFi OS v7+ as it has been replaced by mDNS settings in the network configuration.
        /// </summary>
        [Input("multicastDnsEnabled")]
        public Input<bool>? MulticastDnsEnabled { get; set; }

        /// <summary>
        /// Enable hardware accounting offload. When enabled, the gateway will use hardware acceleration for traffic accounting functions, reducing CPU load and potentially improving throughput for high-traffic environments. This setting may not be supported on all hardware models.
        /// </summary>
        [Input("offloadAccounting")]
        public Input<bool>? OffloadAccounting { get; set; }

        /// <summary>
        /// Enable hardware offload for Layer 2 (L2) blocking functions. When enabled, the gateway will use hardware acceleration for blocking traffic at the data link layer (MAC address level), which can improve performance when implementing MAC-based filtering or isolation. This setting may not be supported on all hardware models.
        /// </summary>
        [Input("offloadL2Blocking")]
        public Input<bool>? OffloadL2Blocking { get; set; }

        /// <summary>
        /// Enable hardware scheduling offload. When enabled, the gateway will use hardware acceleration for packet scheduling functions, which can improve QoS (Quality of Service) performance and throughput for prioritized traffic. This setting may not be supported on all hardware models and may affect other hardware offload capabilities.
        /// </summary>
        [Input("offloadSch")]
        public Input<bool>? OffloadSch { get; set; }

        /// <summary>
        /// Timeout (in seconds) for connection tracking of protocols other than TCP, UDP, and ICMP. This controls how long the gateway maintains state information for connections using other protocols. Higher values maintain connection state longer, while lower values reclaim resources more quickly but may affect some applications using non-standard protocols.
        /// </summary>
        [Input("otherTimeout")]
        public Input<int>? OtherTimeout { get; set; }

        /// <summary>
        /// Enable the PPTP (Point-to-Point Tunneling Protocol) helper module. This module allows PPTP VPN connections to work properly through the gateway's firewall and NAT. PPTP uses GRE for tunneling, so the `GreModule` must also be enabled for PPTP to function correctly. Note that PPTP has known security vulnerabilities and more secure VPN protocols are generally recommended.
        /// </summary>
        [Input("pptpModule")]
        public Input<bool>? PptpModule { get; set; }

        /// <summary>
        /// Enable accepting ICMP redirect messages. ICMP redirects are messages sent by routers to inform hosts of better routes to specific destinations. When enabled, the gateway will update its routing table based on these messages. While useful for route optimization, this can potentially be exploited for man-in-the-middle attacks, so it's often disabled in security-sensitive environments.
        /// </summary>
        [Input("receiveRedirects")]
        public Input<bool>? ReceiveRedirects { get; set; }

        /// <summary>
        /// Enable sending ICMP redirect messages. When enabled, the gateway will send ICMP redirect messages to hosts on the local network to inform them of better routes to specific destinations. This can help optimize network traffic but is typically only needed when the gateway has multiple interfaces on the same subnet or in complex routing scenarios.
        /// </summary>
        [Input("sendRedirects")]
        public Input<bool>? SendRedirects { get; set; }

        /// <summary>
        /// Enable the SIP (Session Initiation Protocol) helper module. SIP is used for initiating, maintaining, and terminating real-time sessions for voice, video, and messaging applications (VoIP, video conferencing). This helper allows SIP-based applications to work correctly through NAT by tracking SIP connections and dynamically opening the necessary ports for media streams.
        /// </summary>
        [Input("sipModule")]
        public Input<bool>? SipModule { get; set; }

        /// <summary>
        /// The name of the UniFi site where this resource should be applied. If not specified, the default site will be used.
        /// </summary>
        [Input("site")]
        public Input<string>? Site { get; set; }

        /// <summary>
        /// Enable SYN cookies to protect against SYN flood attacks. SYN cookies are a technique that helps mitigate TCP SYN flood attacks by avoiding the need to track incomplete connections in a backlog queue. When enabled, the gateway can continue to establish legitimate connections even when under a SYN flood attack. This is a recommended security setting for internet-facing gateways.
        /// </summary>
        [Input("synCookies")]
        public Input<bool>? SynCookies { get; set; }

        /// <summary>
        /// TCP connection timeout settings for various TCP connection states. These settings control how long the gateway maintains state information for TCP connections in different states before removing them from the connection tracking table. Proper timeout values balance resource usage with connection reliability. These settings are particularly relevant when `TimeoutSettingPreference` is set to `Manual`.
        /// </summary>
        [Input("tcpTimeouts")]
        public Input<Inputs.USGTcpTimeoutsArgs>? TcpTimeouts { get; set; }

        /// <summary>
        /// Enable the TFTP (Trivial File Transfer Protocol) helper module. This module allows TFTP connections to work properly through the gateway's firewall and NAT. TFTP is commonly used for firmware updates, configuration file transfers, and network booting of devices. The helper tracks TFTP connections and ensures return traffic is properly handled.
        /// </summary>
        [Input("tftpModule")]
        public Input<bool>? TftpModule { get; set; }

        /// <summary>
        /// Determines how connection timeout values are configured. Valid values are:
        ///   * `Auto` - The gateway will automatically determine appropriate timeout values based on system defaults
        ///   * `Manual` - Use the manually specified timeout values for various connection types
        /// 
        /// When set to `Manual`, you should specify values for the various timeout settings like `TcpTimeouts`, `UdpStreamTimeout`, `UdpOtherTimeout`, `IcmpTimeout`, and `OtherTimeout`. Requires controller version 7.0 or later.
        /// </summary>
        [Input("timeoutSettingPreference")]
        public Input<string>? TimeoutSettingPreference { get; set; }

        /// <summary>
        /// Timeout (in seconds) for general UDP connections. Since UDP is connectionless, this timeout determines how long the gateway maintains state information for UDP packets that don't match the criteria for stream connections. This applies to most short-lived UDP communications like DNS queries. Lower values free resources more quickly but may affect some applications that expect longer session persistence.
        /// </summary>
        [Input("udpOtherTimeout")]
        public Input<int>? UdpOtherTimeout { get; set; }

        /// <summary>
        /// Timeout (in seconds) for UDP stream connections. This applies to UDP traffic patterns that resemble ongoing streams, such as VoIP calls, video streaming, or online gaming. The gateway identifies these based on traffic patterns and maintains state information longer than for regular UDP traffic. Higher values improve reliability for streaming applications but consume more connection tracking resources.
        /// </summary>
        [Input("udpStreamTimeout")]
        public Input<int>? UdpStreamTimeout { get; set; }

        /// <summary>
        /// Unbind WAN monitors to prevent unnecessary traffic. When enabled, the gateway will stop certain monitoring processes that periodically check WAN connectivity. This can reduce unnecessary traffic on metered connections or in environments where the monitoring traffic might trigger security alerts. However, disabling these monitors may affect the gateway's ability to detect and respond to WAN connectivity issues. Requires controller version 9.0 or later.
        /// </summary>
        [Input("unbindWanMonitors")]
        public Input<bool>? UnbindWanMonitors { get; set; }

        /// <summary>
        /// UPNP (Universal Plug and Play) configuration settings. UPNP allows compatible applications and devices to automatically configure port forwarding rules on the gateway without manual intervention. This is commonly used by gaming consoles, media servers, VoIP applications, and other network services that require incoming connections.
        /// </summary>
        [Input("upnp")]
        public Input<Inputs.USGUpnpArgs>? Upnp { get; set; }

        public USGArgs()
        {
        }
        public static new USGArgs Empty => new USGArgs();
    }

    public sealed class USGState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The base reachable timeout (in seconds) for ARP cache entries. This controls how long the gateway considers a MAC-to-IP mapping valid without needing to refresh it. Higher values reduce network traffic but may cause stale entries if devices change IP addresses frequently.
        /// </summary>
        [Input("arpCacheBaseReachable")]
        public Input<int>? ArpCacheBaseReachable { get; set; }

        /// <summary>
        /// The timeout strategy for ARP cache entries. Valid values are:
        ///   * `Normal` - Use system default timeouts
        ///   * `min-dhcp-lease` - Set ARP timeout to match the minimum DHCP lease time
        ///   * `Custom` - Use the custom timeout value specified in `ArpCacheBaseReachable`
        /// 
        /// This setting determines how long MAC-to-IP mappings are stored in the ARP cache before being refreshed.
        /// </summary>
        [Input("arpCacheTimeout")]
        public Input<string>? ArpCacheTimeout { get; set; }

        /// <summary>
        /// Enable responding to broadcast ping requests (ICMP echo requests sent to the broadcast address). When enabled, the gateway will respond to pings sent to the broadcast address of the network (e.g., 192.168.1.255). This can be useful for network diagnostics but may also be used in certain denial-of-service attacks.
        /// </summary>
        [Input("broadcastPing")]
        public Input<bool>? BroadcastPing { get; set; }

        /// <summary>
        /// Advanced DHCP relay configuration settings. Controls how the gateway forwards DHCP requests to external servers and manages DHCP relay agent behavior. Use this block to fine-tune DHCP relay functionality beyond simply specifying relay servers.
        /// </summary>
        [Input("dhcpRelay")]
        public Input<Inputs.USGDhcpRelayGetArgs>? DhcpRelay { get; set; }

        [Input("dhcpRelayServers")]
        private InputList<string>? _dhcpRelayServers;

        /// <summary>
        /// List of up to 5 DHCP relay servers (specified by IP address) that will receive forwarded DHCP requests. This is useful when you want to use external DHCP servers instead of the built-in DHCP server on the USG/UDM. When configured, the gateway will forward DHCP discovery packets from clients to these external servers, allowing centralized IP address management across multiple networks. Example: `['192.168.1.5', '192.168.2.5']`
        /// </summary>
        [Obsolete(@"This attribute is deprecated and will be removed in a future release. `dhcp_relay.servers` attribute will be introduced as a replacement.")]
        public InputList<string> DhcpRelayServers
        {
            get => _dhcpRelayServers ?? (_dhcpRelayServers = new InputList<string>());
            set => _dhcpRelayServers = value;
        }

        /// <summary>
        /// Enable updating the gateway's host files with DHCP client information. When enabled, the gateway will automatically add entries to its host file for each DHCP client, allowing hostname resolution for devices that receive IP addresses via DHCP. This improves name resolution on the local network.
        /// </summary>
        [Input("dhcpdHostfileUpdate")]
        public Input<bool>? DhcpdHostfileUpdate { get; set; }

        /// <summary>
        /// Use dnsmasq for DHCP services instead of the default DHCP server. Dnsmasq provides integrated DNS and DHCP functionality with additional features like DNS caching, DHCP static leases, and local domain name resolution. This can improve DNS resolution performance and provide more flexible DHCP options.
        /// </summary>
        [Input("dhcpdUseDnsmasq")]
        public Input<bool>? DhcpdUseDnsmasq { get; set; }

        /// <summary>
        /// DNS verification settings for validating DNS responses. This feature helps detect and prevent DNS spoofing attacks by verifying DNS responses against trusted DNS servers. When configured, the gateway can compare DNS responses with those from known trusted servers to identify potential tampering or poisoning attempts. Requires controller version 8.5 or later.
        /// </summary>
        [Input("dnsVerification")]
        public Input<Inputs.USGDnsVerificationGetArgs>? DnsVerification { get; set; }

        /// <summary>
        /// When enabled, dnsmasq will query all configured DNS servers simultaneously and use the fastest response. This can improve DNS resolution speed but may increase DNS traffic. By default, dnsmasq queries servers sequentially, only trying the next server if the current one fails to respond.
        /// </summary>
        [Input("dnsmasqAllServers")]
        public Input<bool>? DnsmasqAllServers { get; set; }

        /// <summary>
        /// The hostname or IP address of a server to use for network echo tests. Echo tests send packets to this server and measure response times to evaluate network connectivity and performance. This can be used for network diagnostics and monitoring.
        /// </summary>
        [Input("echoServer")]
        public Input<string>? EchoServer { get; set; }

        /// <summary>
        /// Enable the FTP (File Transfer Protocol) helper module. This module allows the gateway to properly handle FTP connections through NAT by tracking the control channel and dynamically opening required data ports. Without this helper, passive FTP connections may fail when clients are behind NAT.
        /// </summary>
        [Input("ftpModule")]
        public Input<bool>? FtpModule { get; set; }

        /// <summary>
        /// Geographic IP filtering configuration that allows blocking or allowing traffic based on country of origin. This feature uses IP geolocation databases to identify the country associated with IP addresses and apply filtering rules. Useful for implementing country-specific access policies or blocking traffic from high-risk regions. Requires controller version 7.0 or later.
        /// </summary>
        [Input("geoIpFiltering")]
        public Input<Inputs.USGGeoIpFilteringGetArgs>? GeoIpFiltering { get; set; }

        /// <summary>
        /// Whether Geo IP Filtering is enabled. When enabled, the gateway will apply the specified country-based
        /// </summary>
        [Input("geoIpFilteringEnabled")]
        public Input<bool>? GeoIpFilteringEnabled { get; set; }

        /// <summary>
        /// Enable the GRE (Generic Routing Encapsulation) protocol helper module. This module allows proper handling of GRE tunneling protocol through the gateway's firewall. GRE is commonly used for VPN tunnels and other encapsulation needs. Required if you plan to use PPTP VPNs (see `PptpModule`).
        /// </summary>
        [Input("greModule")]
        public Input<bool>? GreModule { get; set; }

        /// <summary>
        /// Enable the H.323 protocol helper module. H.323 is a standard for multimedia communications (audio, video, and data) over packet-based networks. This helper allows H.323-based applications like video conferencing systems to work properly through NAT by tracking connection details and opening required ports.
        /// </summary>
        [Input("h323Module")]
        public Input<bool>? H323Module { get; set; }

        /// <summary>
        /// ICMP timeout in seconds for connection tracking. This controls how long the gateway maintains state information for ICMP (ping) packets in its connection tracking table. Higher values maintain ICMP connection state longer, while lower values reclaim resources more quickly but may affect some diagnostic tools.
        /// </summary>
        [Input("icmpTimeout")]
        public Input<int>? IcmpTimeout { get; set; }

        /// <summary>
        /// Enable Link Layer Discovery Protocol (LLDP) on all interfaces. LLDP is a vendor-neutral protocol that allows network devices to advertise their identity, capabilities, and neighbors on a local network. When enabled, the gateway will both send and receive LLDP packets, facilitating network discovery and management tools.
        /// </summary>
        [Input("lldpEnableAll")]
        public Input<bool>? LldpEnableAll { get; set; }

        /// <summary>
        /// TCP Maximum Segment Size (MSS) clamping mode. MSS clamping adjusts the maximum segment size of TCP packets to prevent fragmentation issues when packets traverse networks with different MTU sizes. Valid values include:
        ///   * `Auto` - Automatically determine appropriate MSS values based on interface MTUs
        ///   * `Custom` - Use the custom MSS value specified in `MssClampMss`
        ///   * `Disabled` - Do not perform MSS clamping
        /// 
        /// This setting is particularly important for VPN connections and networks with non-standard MTU sizes.
        /// </summary>
        [Input("mssClamp")]
        public Input<string>? MssClamp { get; set; }

        /// <summary>
        /// Custom TCP Maximum Segment Size (MSS) value in bytes. This value is used when `MssClamp` is set to `Custom`. The MSS value should typically be set to the path MTU minus 40 bytes (for IPv4) or minus 60 bytes (for IPv6) to account for TCP/IP header overhead. Valid values range from 100 to 9999, with common values being 1460 (for standard 1500 MTU) or 1400 (for VPN tunnels).
        /// </summary>
        [Input("mssClampMss")]
        public Input<int>? MssClampMss { get; set; }

        /// <summary>
        /// Enable multicast DNS (mDNS/Bonjour/Avahi) forwarding across VLANs. This allows devices to discover services (like printers, Chromecasts, Apple devices, etc.) even when they are on different networks or VLANs. When enabled, the gateway will forward mDNS packets between networks, facilitating cross-VLAN service discovery. Note: This setting is not supported on UniFi OS v7+ as it has been replaced by mDNS settings in the network configuration.
        /// </summary>
        [Input("multicastDnsEnabled")]
        public Input<bool>? MulticastDnsEnabled { get; set; }

        /// <summary>
        /// Enable hardware accounting offload. When enabled, the gateway will use hardware acceleration for traffic accounting functions, reducing CPU load and potentially improving throughput for high-traffic environments. This setting may not be supported on all hardware models.
        /// </summary>
        [Input("offloadAccounting")]
        public Input<bool>? OffloadAccounting { get; set; }

        /// <summary>
        /// Enable hardware offload for Layer 2 (L2) blocking functions. When enabled, the gateway will use hardware acceleration for blocking traffic at the data link layer (MAC address level), which can improve performance when implementing MAC-based filtering or isolation. This setting may not be supported on all hardware models.
        /// </summary>
        [Input("offloadL2Blocking")]
        public Input<bool>? OffloadL2Blocking { get; set; }

        /// <summary>
        /// Enable hardware scheduling offload. When enabled, the gateway will use hardware acceleration for packet scheduling functions, which can improve QoS (Quality of Service) performance and throughput for prioritized traffic. This setting may not be supported on all hardware models and may affect other hardware offload capabilities.
        /// </summary>
        [Input("offloadSch")]
        public Input<bool>? OffloadSch { get; set; }

        /// <summary>
        /// Timeout (in seconds) for connection tracking of protocols other than TCP, UDP, and ICMP. This controls how long the gateway maintains state information for connections using other protocols. Higher values maintain connection state longer, while lower values reclaim resources more quickly but may affect some applications using non-standard protocols.
        /// </summary>
        [Input("otherTimeout")]
        public Input<int>? OtherTimeout { get; set; }

        /// <summary>
        /// Enable the PPTP (Point-to-Point Tunneling Protocol) helper module. This module allows PPTP VPN connections to work properly through the gateway's firewall and NAT. PPTP uses GRE for tunneling, so the `GreModule` must also be enabled for PPTP to function correctly. Note that PPTP has known security vulnerabilities and more secure VPN protocols are generally recommended.
        /// </summary>
        [Input("pptpModule")]
        public Input<bool>? PptpModule { get; set; }

        /// <summary>
        /// Enable accepting ICMP redirect messages. ICMP redirects are messages sent by routers to inform hosts of better routes to specific destinations. When enabled, the gateway will update its routing table based on these messages. While useful for route optimization, this can potentially be exploited for man-in-the-middle attacks, so it's often disabled in security-sensitive environments.
        /// </summary>
        [Input("receiveRedirects")]
        public Input<bool>? ReceiveRedirects { get; set; }

        /// <summary>
        /// Enable sending ICMP redirect messages. When enabled, the gateway will send ICMP redirect messages to hosts on the local network to inform them of better routes to specific destinations. This can help optimize network traffic but is typically only needed when the gateway has multiple interfaces on the same subnet or in complex routing scenarios.
        /// </summary>
        [Input("sendRedirects")]
        public Input<bool>? SendRedirects { get; set; }

        /// <summary>
        /// Enable the SIP (Session Initiation Protocol) helper module. SIP is used for initiating, maintaining, and terminating real-time sessions for voice, video, and messaging applications (VoIP, video conferencing). This helper allows SIP-based applications to work correctly through NAT by tracking SIP connections and dynamically opening the necessary ports for media streams.
        /// </summary>
        [Input("sipModule")]
        public Input<bool>? SipModule { get; set; }

        /// <summary>
        /// The name of the UniFi site where this resource should be applied. If not specified, the default site will be used.
        /// </summary>
        [Input("site")]
        public Input<string>? Site { get; set; }

        /// <summary>
        /// Enable SYN cookies to protect against SYN flood attacks. SYN cookies are a technique that helps mitigate TCP SYN flood attacks by avoiding the need to track incomplete connections in a backlog queue. When enabled, the gateway can continue to establish legitimate connections even when under a SYN flood attack. This is a recommended security setting for internet-facing gateways.
        /// </summary>
        [Input("synCookies")]
        public Input<bool>? SynCookies { get; set; }

        /// <summary>
        /// TCP connection timeout settings for various TCP connection states. These settings control how long the gateway maintains state information for TCP connections in different states before removing them from the connection tracking table. Proper timeout values balance resource usage with connection reliability. These settings are particularly relevant when `TimeoutSettingPreference` is set to `Manual`.
        /// </summary>
        [Input("tcpTimeouts")]
        public Input<Inputs.USGTcpTimeoutsGetArgs>? TcpTimeouts { get; set; }

        /// <summary>
        /// Enable the TFTP (Trivial File Transfer Protocol) helper module. This module allows TFTP connections to work properly through the gateway's firewall and NAT. TFTP is commonly used for firmware updates, configuration file transfers, and network booting of devices. The helper tracks TFTP connections and ensures return traffic is properly handled.
        /// </summary>
        [Input("tftpModule")]
        public Input<bool>? TftpModule { get; set; }

        /// <summary>
        /// Determines how connection timeout values are configured. Valid values are:
        ///   * `Auto` - The gateway will automatically determine appropriate timeout values based on system defaults
        ///   * `Manual` - Use the manually specified timeout values for various connection types
        /// 
        /// When set to `Manual`, you should specify values for the various timeout settings like `TcpTimeouts`, `UdpStreamTimeout`, `UdpOtherTimeout`, `IcmpTimeout`, and `OtherTimeout`. Requires controller version 7.0 or later.
        /// </summary>
        [Input("timeoutSettingPreference")]
        public Input<string>? TimeoutSettingPreference { get; set; }

        /// <summary>
        /// Timeout (in seconds) for general UDP connections. Since UDP is connectionless, this timeout determines how long the gateway maintains state information for UDP packets that don't match the criteria for stream connections. This applies to most short-lived UDP communications like DNS queries. Lower values free resources more quickly but may affect some applications that expect longer session persistence.
        /// </summary>
        [Input("udpOtherTimeout")]
        public Input<int>? UdpOtherTimeout { get; set; }

        /// <summary>
        /// Timeout (in seconds) for UDP stream connections. This applies to UDP traffic patterns that resemble ongoing streams, such as VoIP calls, video streaming, or online gaming. The gateway identifies these based on traffic patterns and maintains state information longer than for regular UDP traffic. Higher values improve reliability for streaming applications but consume more connection tracking resources.
        /// </summary>
        [Input("udpStreamTimeout")]
        public Input<int>? UdpStreamTimeout { get; set; }

        /// <summary>
        /// Unbind WAN monitors to prevent unnecessary traffic. When enabled, the gateway will stop certain monitoring processes that periodically check WAN connectivity. This can reduce unnecessary traffic on metered connections or in environments where the monitoring traffic might trigger security alerts. However, disabling these monitors may affect the gateway's ability to detect and respond to WAN connectivity issues. Requires controller version 9.0 or later.
        /// </summary>
        [Input("unbindWanMonitors")]
        public Input<bool>? UnbindWanMonitors { get; set; }

        /// <summary>
        /// UPNP (Universal Plug and Play) configuration settings. UPNP allows compatible applications and devices to automatically configure port forwarding rules on the gateway without manual intervention. This is commonly used by gaming consoles, media servers, VoIP applications, and other network services that require incoming connections.
        /// </summary>
        [Input("upnp")]
        public Input<Inputs.USGUpnpGetArgs>? Upnp { get; set; }

        /// <summary>
        /// Whether UPNP is enabled. When enabled, the gateway will automatically forward ports for UPNP-compatible devices
        /// </summary>
        [Input("upnpEnabled")]
        public Input<bool>? UpnpEnabled { get; set; }

        public USGState()
        {
        }
        public static new USGState Empty => new USGState();
    }
}
