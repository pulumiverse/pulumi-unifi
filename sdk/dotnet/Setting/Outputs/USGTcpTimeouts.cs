// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace Pulumiverse.Unifi.Setting.Outputs
{

    [OutputType]
    public sealed class USGTcpTimeouts
    {
        /// <summary>
        /// Timeout (in seconds) for TCP connections in the CLOSE state. The CLOSE state occurs when a connection is being terminated but may still have packets in transit. Lower values reclaim resources more quickly, while higher values ensure all packets are properly processed during connection termination.
        /// </summary>
        public readonly int? CloseTimeout;
        /// <summary>
        /// Timeout (in seconds) for TCP connections in the CLOSE_WAIT state. The CLOSE_WAIT state occurs when the remote end has initiated connection termination, but the local application hasn't closed the connection yet. This timeout prevents resources from being held indefinitely if a local application fails to properly close its connection.
        /// </summary>
        public readonly int? CloseWaitTimeout;
        /// <summary>
        /// Timeout (in seconds) for TCP connections in the ESTABLISHED state. This is the most important TCP timeout as it determines how long idle but established connections are maintained in the connection tracking table. Higher values (e.g., 86400 = 24 hours) are suitable for long-lived connections, while lower values conserve resources but may cause issues with applications that maintain idle connections.
        /// </summary>
        public readonly int? EstablishedTimeout;
        /// <summary>
        /// Timeout (in seconds) for TCP connections in the FIN_WAIT state. The FIN_WAIT states occur during the normal TCP connection termination process after a FIN packet has been sent. This timeout prevents resources from being held if the connection termination process doesn't complete properly.
        /// </summary>
        public readonly int? FinWaitTimeout;
        /// <summary>
        /// Timeout (in seconds) for TCP connections in the LAST_ACK state. The LAST_ACK state occurs during connection termination when the remote end has sent a FIN, the local end has responded with a FIN and ACK, and is waiting for the final ACK from the remote end to complete the connection termination.
        /// </summary>
        public readonly int? LastAckTimeout;
        /// <summary>
        /// Timeout (in seconds) for TCP connections in the SYN_RECV state. This state occurs during connection establishment after receiving a SYN packet and sending a SYN-ACK, but before receiving the final ACK to complete the three-way handshake. A lower timeout helps mitigate SYN flood attacks by releasing resources for incomplete connections more quickly.
        /// </summary>
        public readonly int? SynRecvTimeout;
        /// <summary>
        /// Timeout (in seconds) for TCP connections in the SYN_SENT state. This state occurs during connection establishment after sending a SYN packet but before receiving a SYN-ACK response. This timeout determines how long the system will wait for a response to connection attempts before giving up.
        /// </summary>
        public readonly int? SynSentTimeout;
        /// <summary>
        /// Timeout (in seconds) for TCP connections in the TIME_WAIT state. The TIME_WAIT state occurs after a connection has been closed but is maintained to ensure any delayed packets are properly handled. The standard recommendation is 2 minutes (120 seconds), but can be reduced in high-connection environments to free resources more quickly at the risk of potential connection issues if delayed packets arrive.
        /// </summary>
        public readonly int? TimeWaitTimeout;

        [OutputConstructor]
        private USGTcpTimeouts(
            int? closeTimeout,

            int? closeWaitTimeout,

            int? establishedTimeout,

            int? finWaitTimeout,

            int? lastAckTimeout,

            int? synRecvTimeout,

            int? synSentTimeout,

            int? timeWaitTimeout)
        {
            CloseTimeout = closeTimeout;
            CloseWaitTimeout = closeWaitTimeout;
            EstablishedTimeout = establishedTimeout;
            FinWaitTimeout = finWaitTimeout;
            LastAckTimeout = lastAckTimeout;
            SynRecvTimeout = synRecvTimeout;
            SynSentTimeout = synSentTimeout;
            TimeWaitTimeout = timeWaitTimeout;
        }
    }
}
